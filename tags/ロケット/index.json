[{"content":"CapsLock+WASDを↑←↓→にする方法\n概要 頻繁に使用する矢印キーは右の小指で押しづらい位置にあるのに、最も要らないCapsLockキーはとても押しやすい位置にあります。そしてCapsLockの隣には移動でおなじみのWASDキーがあります。CapsLock+WASDを↑←↓→にするのは必然です。必ず設定しましょう。\n Change KeyでCapsLockキーをF13キーと認識させる AutoHotkeyでF13+WASDを↑←↓→にする  Change Key 後述するAutoHotkeyではCapsLockを認識できないことがあるので、別のソフトを使ってF13として認識させます。\n 窓の杜からインストールします。 Change Keyを起動し、CapsLockキーを選択します。\n 右上のscan codeをクリックします。\n F13のスキャンコードである0064を入力します。\n 「登録」してから「終了」します。\n  AutoHotkey  公式サイトからインストールします。 任意のディレクトリに、以下の内容の\u0026quot;hoge.ahk\u0026quot;というファイルを作成します。 1 2 3 4  sc0064 \u0026amp; w::Send, {Up} sc0064 \u0026amp; a::Send, {Left} sc0064 \u0026amp; s::Send, {Down} sc0064 \u0026amp; d::Send, {Right}    作成した\u0026quot;hoge.ahk\u0026quot;をダブルクリックして起動し、正常に動作していることを確認します。 \u0026ldquo;hoge.ahk\u0026quot;のショートカットを作成し、こちらのサイトの通りにスタートアップに登録します。\n ","description":"","id":0,"section":"blog","tags":null,"title":"WASDを↑←↓→にしよう！","uri":"https://771-8bit.com/blog/wasd2arrow/"},{"content":"今はリンクを知っている人だけ見れます。\n開発用資料+引継資料+公開用資料\nはじめに 鳥人間コンテスト滑空機部門の電装の開発についてまとめます。\n設計の根拠がわかるように、要求定義から記録に残しました。\ngantt dateFormat YYYY-MM-DD axisFormat %Y-%m todayMarker off excludes weekends %% (`excludes` accepts specific dates in YYYY-MM-DD format, days of the week (\"sunday\") or \"weekends\", but not the word \"weekdays\".) section システム設計 ミッション要求定義 :req_def , 2022-10-17,2022-10-27 システム要求分析 :req_analysis , after req_def , 7d 機能設計 :Functional_design , after req_analysis , 7d 物理設計 :physical_design , after Functional_design , 7d section 操舵系 構成部品候補の調査・試作 :research , 2022-10-17,14d BBM製作 :BBM , after research , 14d FM製作 :FM , after BBM , 14d section 高度計 section ロガー section サークル全体 桁試験 : milestone, 2022-12-24,1d 新歓 : milestone, 2023-04-24,1d 初全組 : milestone, 2023-06-17,1d 初TF : milestone, 2023-06-17,1d 鳥コン : milestone, 2023-07-23,1d   (function () { if (window.isMermaidLoaded) return; window.isMermaidLoaded = true; const script = document.createElement('script'); script.src = 'https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js'; script.onload = () = { mermaid.initialize({ startOnLoad: true }); }; document.body.appendChild(script); })();  -- 設計 要求定義  システムの要求  パイロットの操作でラダーを制御する パイロットに対地高度を伝達する フライトデータを取得する   電装班運営の要求  必要な技術を継承する    要求分析 共通事項  フライトまでバッテリーが持つ 着水時に発煙・発火しない メンテナンス性  プラットフォーム上でメイン電装の電源を起動できる メイン電装部を機体から取り外した状態で、機体に取り付けた各電装部と電気的に接続して動作テストができる   耐候性  機体が直射日光にあたり温度が上昇しても動作する 多少の水滴では故障せず動作し続ける (直射日光下で)LEDを見る必要なく運用できる   電気的制約  SPIは通信速度が速く、I2Cはプルアップが不安定なため基板内のみの使用とする 基板間の通信はUARTおよびそれに近い規格(RS422など)とし、波形をオシロスコープで確認する マイコンの動作電圧は多くのセンサーに合わせて基本3.3Vとする   技術(力)的制約  Arduinoを使用し、自力でライブラリを書かなくて良い構成とする CANはなるべく使用せず、UARTによる文字列送受信を行う    操舵  パイロットの操作でラダーを制御する  入力を読む  ゼロ点を認識する 任意のカーブを設定できる   ラダーを動かす  十分なトルクがある  風   信号・電力の減衰が起きない  ケーブルが断線しない ケーブルの電圧降下が小さい       その他の要件  トラブル時ニュートラルでフライトできる テールを軽くする 操舵系のみの電源供給、操舵系以外のみの電源供給の両方が選択可能である    高度計  パイロットに対地高度を伝達する  対地高度を推定する  測定精度は0.1m単位を要求 技術的な制約  高高度では気圧高度を、低高度では超音波高度を信用すべき  気圧高度は湖面からの絶対高度は分からない 超音波は高高度からでは届かない   気圧センサ  動圧・ハッチの衝撃によるセンサーの外れ値を弾く 中央値を取るために違う場所に3つの気圧センサを配置する   超音波センサ  水面付近は気圧高度より信用できる       パイロットに情報を伝達する  モニター、表示機以外で伝達する  テープLED 聴覚 触覚       その他の要件\n*  ロギング  下記のデータを記録する     優先度 測定値 要求     高 GPS ある程度信頼できるため冗長の必要はない   高 超音波高度 超音波が干渉するため一つだけ搭載する   高 気圧高度 高度計の信頼性を確保できる分だけ搭載する   中 ラダー操作量 どの故障モードでもラダー操作に影響を与えない   中 9軸・姿勢 複数搭載なら異種のセンサーを搭載する   中 差圧 機体外に搭載する必要がある   低 AoA 機体外に搭載する必要がある   低 AoS 機体外に搭載する必要がある     データを同期した状態で記録する 着水時にデータをロストしない  requirementDiagram requirement test_req { id: 1 text: \"パイロットの操作でラダーを制御する\" risk: high verifymethod: demonstration } functionalRequirement req_input { id: 1.3 text: \"入力を読む\" risk: medium verifymethod: demonstration } interfaceRequirement input_feedback { id: 1.5 text: \"入力値をパイロットが認識できる\" risk: medium verifymethod: demonstration } interfaceRequirement input_zero { id: 1.5 text: \"ゼロ点を認識する\" risk: medium verifymethod: demonstration } interfaceRequirement input_curve { id: 1.6 text: \"任意のカーブを設定できる\" risk: medium verifymethod: demonstration } functionalRequirement req_servo { id: 1.2 text: \"ラダーを動かす\" risk: medium verifymethod: demonstration } physicalRequirement req_wire { id: 1.2 text: \"信号・電力の減衰が起きない\" risk: medium verifymethod: demonstration } physicalRequirement req_break { id: 1.2 text: \"ケーブルが断線しない\" risk: medium verifymethod: demonstration } physicalRequirement req_voltage_drop { id: 1.2 text: \"ケーブルの電圧降下が小さい\" risk: medium verifymethod: demonstration } physicalRequirement req_voltage_drop { id: 1.2 text: \"サーボの電流が増える\" risk: medium verifymethod: demonstration } physicalRequirement req_wind { id: 1.2 text: \"風による外力を受けても動作する\" risk: medium verifymethod: demonstration } performanceRequirement req_battery { id: 1.9 text: \"フライトまでバッテリーが持つ\" risk: medium verifymethod: demonstration } designConstraint req_weight { id: 1 text: \"テールを軽くする\" risk: high verifymethod: demonstration } designConstraint weight_cable { id: 1 text: \"ケーブルを軽くする\" risk: high verifymethod: demonstration } physicalRequirement req_failsafe { id: 1.2 text: \"トラブル時ニュートラルでフライトできる\" risk: medium verifymethod: demonstration } test_req - contains - req_input req_input - contains - input_zero req_input - contains - input_curve req_input - contains - input_feedback test_req - contains - req_servo req_servo - satisfies - req_wire req_servo - satisfies - req_wind test_req - derives - req_battery req_input req_failsafe req_servo  (function () { if (window.isMermaidLoaded) return; window.isMermaidLoaded = true; const script = document.createElement('script'); script.src = 'https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js'; script.onload = () = { mermaid.initialize({ startOnLoad: true }); }; document.body.appendChild(script); })();  requirementDiagram requirement test_req { id: 1 text: \"対地高度の伝達\" risk: high verifymethod: test } functionalRequirement test_req2 { id: 1.1 text: the second test text. risk: low verifymethod: inspection } performanceRequirement test_req3 { id: 1.2 text: the third test text. risk: medium verifymethod: demonstration } interfaceRequirement test_req4 { id: 1.2.1 text: the fourth test text. risk: medium verifymethod: analysis } physicalRequirement test_req5 { id: 1.2.2 text: the fifth test text. risk: medium verifymethod: analysis } designConstraint test_req6 { id: 1.2.3 text: the sixth test text. risk: medium verifymethod: analysis } element test_entity { type: simulation } element test_entity2 { type: word doc docRef: reqs/test_entity } element test_entity3 { type: \"test suite\" docRef: github.com/all_the_tests } test_entity - satisfies - test_req2 test_req - traces - test_req2 test_req - contains - test_req3 test_req3 - contains - test_req4 test_req4 - derives - test_req5 test_req5 - refines - test_req6 test_entity3 - verifies - test_req5 test_req  (function () { if (window.isMermaidLoaded) return; window.isMermaidLoaded = true; const script = document.createElement('script'); script.src = 'https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js'; script.onload = () = { mermaid.initialize({ startOnLoad: true }); }; document.body.appendChild(script); })();  -- 機能設計  要求から設計への落とし込みの根拠  マイコンの駆動電圧は3.3V(センサーの制約)     物理設計    コンポーネント 予算     メイン電装部(メインマイコン) 0,000   メイン電装部(操舵系) 0,000   機体下部電装部 0,000   エアデータ電装部 0,000    UARTフォーマット 桁が固定されていない小数をカンマ区切りで送信し、改行コードLF(\\n)をつける。ボーレートは115200bpsとする。\n気圧[hPa],温度[deg],気圧高度[m],超音波高度[m]\n気圧[hPa],温度[deg],気圧高度[m],差圧[Pa],対気速度[m/ss],AoA[rad],AoS[rad]\nメイン電装部(メインマイコン)  以下のタスクを実行する。SDカードへのアクセスは時間がかかるため、SPIをSDカード専用バスとしたうえでflash_SDのみ他からのプリエンプションを認める。これ以外のタスクはプリエンプションは認めず順番に実行する。\n    タスク名 起動周期 概要     read_UART TBD ジョイスティック電装部・機体下部電装部・エアデータ電装部・GPSからのデータ受信   read_inner_sensors 100 Hz メインマイコンに直接接続されたGPSを除いたセンサーのデータ取得   flash_SD 1 Hz SDカードへの書き込み   callout_altitude 0.5 Hz 高度の読み上げ    メイン電装部(操舵系)    部品 個数 価格     KRS-4034HV ICS 2(予備含む) 17,600   ICS変換基板 1 1980    機体下部電装部 エアデータ電装部 製作 役割分担  メイン電装部(メインマイコン)担当  電子工作経験者に任せる。   メイン電装部(操舵系)担当  だいたいはEclatの引き継ぎで、ジョイスティックまわりをブラッシュアップするだけ。   エアデータセンサ電装部(5孔ピトー管)担当  斜めにも穴をつけることで風向風速が取れる5孔ピトー管を自作する(基本売ってない)。   エアデータセンサ電装部(迎え角・滑り角センサ)担当  羽根を製作して角度センサにつけて風向を取得する。   機体下部電装部(超音波センサ)担当  超音波センサで対地高度を取る。高度読み上げに使うので水面や光の状況など徹底してテストを行う。   画像認識担当  回収したカメラ映像をもとに姿勢を推定する。リアルタイム処理の必要はない。    ソフトウェアの管理  GitHub  organization 使い方  公式ドキュメント 動画 Conventional Commits      コンポーネントごとの製作 メイン電装部(メインマイコン) graph LR データをSDに記録データをSDに記録] 高度読み上げ高度読み上げ] タスクのスケジューリング確定タスクのスケジューリング確定] データを取得--データをSDに記録 SDへの書き込み-------データをSDに記録 UARTの文字列をパースして数値を取得 UARTの文字列をパースして数値を取得--エアデータのデータ取得 UARTの文字列をパースして数値を取得--機体下のデータ取得 9軸センサのデータ取得---メイン電装部のセンサーデータ取得 GPSのデータ取得---メイン電装部のセンサーデータ取得 メイン気圧高度取得--メイン電装部のセンサーデータ取得 メイン気圧高度取得--気圧高度の中央値の取得 メイン電装部のセンサーデータ取得--データを取得 機体下のデータ取得--データを取得 エアデータのデータ取得--データを取得 操舵量取得---データを取得 対地高度の推定--データを取得 エアデータのデータ取得--エアデータ気圧高度取得 機体下のデータ取得--機体下気圧高度取得 機体下のデータ取得--超音波高度の取得 エアデータ気圧高度取得--気圧高度の中央値の取得 機体下気圧高度取得--気圧高度の中央値の取得 気圧高度の中央値の取得--対地高度の推定 超音波高度の取得--対地高度の推定 対地高度の推定---高度読み上げ 音声合成ICとの通信--音声合成 スピーカのアンプ回路--音声合成 音声合成--高度読み上げ タイマ割り込み--タスクのスケジューリング確定 UARTの文字列をパースして数値を取得--タスクのスケジューリング確定 SDへの書き込み--タスクのスケジューリング確定 click SDへの書き込み \"/secret/birdman-glider-avionics/#SDへの書き込み\" _blank click UARTの文字列をパースして数値を取得 \"/secret/birdman-glider-avionics/#UART\" _blank click タイマ割り込み \"/secret/birdman-glider-avionics/#タイマ割り込み\" _blank click 9軸センサのデータ取得 \"/secret/birdman-glider-avionics/#BNO055\" _blank click メイン気圧高度取得 \"/secret/birdman-glider-avionics/#BME280\" _blank click GPSのデータ取得 \"/secret/birdman-glider-avionics/#GT-902PMGG\" _blank click 音声合成ICとの通信 \"/secret/birdman-glider-avionics/#ATP3012F6-PU\" _blank   (function () { if (window.isMermaidLoaded) return; window.isMermaidLoaded = true; const script = document.createElement('script'); script.src = 'https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js'; script.onload = () = { mermaid.initialize({ startOnLoad: true }); }; document.body.appendChild(script); })();  Arduino Due  Arduino Due 1 Arduino Due 2  \nSDへの書き込み  ピン配置  \nUART SerialUSB (Native USB Port only)に注意\n 公式リファレンス XIAO ピン配置  \nタイマ割り込み SDカードの書き込みは時間がかかるのでSDへのアクセスはloop()内で、他のタスクはタイマ割り込みで行う。ただし音声合成ICとの通信では厳密なリアルタイム性は求めないのでloop()内で行う(音声合成ICのタイミングチャート確認済み)。UARTの通信にも割り込みが使われており、これよりタイマ割り込みの優先度が高いと正常に動作しない。このため優先度はSysTickを14、タイマ割り込みを15(最低)とする。DueTimerを使用した上でNVIC_SetPriority()により優先度を設定する。\n DueTimer 割り込みの優先度詳解 データシート該当部  \nBME280  秋月商品ページ Arduinoライブラリ  \nBNO055  秋月商品ページ チップデータシート Arduinoライブラリ  \nGT-902PMGG  秋月商品ページ  \nATP3012F6-PU  秋月商品ページ  メイン電装部(操舵系) 機体下部電装部 エアデータ電装部 完成したシステム 回路図とかプログラムとか\n","description":"","id":1,"section":"secret","tags":null,"title":"鳥コン滑空機の電装の開発","uri":"https://771-8bit.com/secret/birdman-glider-avionics/"},{"content":"セキュリティ・キャンプ2022のX3【ハードウェア魔改造ゼミ】の参加記です。ルーターにArduinoをつなげてスマホから操作できるラジコンを作りました。\nX3 ハードウェア魔改造ゼミ 概要 Wi-FiルーターにArduinoをつなげてスマホやパソコンから操作できるラジコンを作りました。セキュリティキャンプの中でも異色のゼミですが、分野を問わず存在する攻撃から守るために幅広い分野について知るべきで、電気回路からHTTPまで全レイヤーを触ってみようという趣旨になっています。\n この講義は電波法への抵触リスクに慎重に配慮して実施されていると講師から案内がありました。また、講義内でも電波法について学んだ上で制作しました。 ハードウェア構成 黒枠内のラジコンにWi-Fiルーターを搭載し、スマホ・パソコンなどのクライアントからHTTPでルーターのサーバーと通信して操作します。モーターはルーターにUSBケーブルで繋いだArduinoからモータードライバ経由で回します。\n GL.iNet GL-MT300N-V2  このルーターにはオープンソースのOpenWrtが初めからインストールされていて、Raspberry Piのようなシングルボードコンピュータとして扱えます。無線通信に関するコードを直接書き換えることはしないので、Raspberry Piのプログラミングと同じように電波法には抵触しません。   Arduino Nano Every TB6612使用 Dual DCモータードライブキット ツインモーターギヤーボックス  Arduinoからモーターを回す ArduinoはUARTで以下の情報を受け取ります。\n 左右のモーターの回転方向（ブレーキ・ニュートラル・時計回り・反時計回り） 左右のモーターの回転速度\n  これをモータードライバに伝えてモーターを回します。\n モータードライバのHブリッジ回路で回転方向を切り替え ONとOFFを高速に切り替え(PWM)、平均電力をコントロールして速度調整\n  今回は電源がモバイルバッテリーの5V系一つしかないため、モーターの大電流による電圧降下からArduino・ルーターを守る必要がありました。\n 回路にコンデンサを追加して瞬間的な電流をカバー PWMのON/OFF比(Duty比)の最大値を低くする PWM周期を短くして電源電圧の振動を軽減 Duty比をゆっくり目標値に近づける 過負荷で電源電圧が落ちたらDuty比を半分にする  以下のオシロスコープの波形は黄色がPWM信号、青色がラジコン全体の電源電圧です。\n\nサーバーの実装 ArduinoをUSBケーブルでルーターに繋ぎ、MicroPythonからモーターの状態をUARTで操作します。このMicroPythonの上にnanowebというフレームワークでWebサーバーを実装します。\n以下の機能を実装しました。\n 矢印・STOP ボタンによる前後左右の動作 レンジスライダーによる左右のモーターの直接操作 ポーリングにより状態を同期し、複数クライアントでの同時操作に対応  ラジコンのフェイルセーフ HTTPでやりとりするリソースであるJSONのデコードに失敗するバグが発生しました。時間内に根本原因は特定できませんでしたが、try-exceptで対処しました。他にもバグがある可能性に備えて、フェイルセーフとして異常終了時にはモーターを停止するようにプログラムを変更しました。\n1 2 3 4 5  try: loop.run_forever() //メインループ開始 finally: s.write(\u0026#39;0,0,0,0;\u0026#39;) //Arduinoにモーター停止を伝える s.close() //シリアルポートを閉じる   コントローラーのフロントエンド実装 JavaScriptはサーバーとの通信に関わるのでそれなりに理解する必要がありましたが、HTMLやCSSは雰囲気で書きました。よくわからんが、まぁ動いてるからヨシ！\n日記 日記という名のメモ\n8/8(1日目)  開講式・LT会・共通講義・グループワークのみで開発ゼミの時間はなし  8/9(2日目) 電気回路  STBYピンを基板内部でプルアップ モーターの極性は揃えた 電流食い過ぎ\u0026amp;電圧ヤバすぎ問題に気づく  とりあえずたくさんコンデンサをつける  470uFと100uFを外付け 基板内に10uFの積セラあり   分圧してADCにつっこむ回路を組む  基準電圧が電源電圧だと意味がないので1.1V基準にするため12kと3kで分圧 INTERNALじゃだめでINTERNAL1V1でやった      マイコン開発  電圧降下対策でPWMの周期を早めた  Hの時間が長かったらその間ずっと降下する 手順  ググって出てきたブログで叩くべきレジスタを特定 データシートを読んで内容を理解、レジスタを書き換える TCAを書き換えたためPWMと一緒にdelayも爆速になってしまうことを確認。一度はdelay_msをdelay*64で用意して乗り切ろうとした ググってQiitaでタイマの割当を知り、使うタイマとPWMピンを変更。それに合わせてレジスタを叩く     ロケットのテレメトリのコードを移植してカンマ区切りでデータを渡せるようにした (爆アド)  ルーターセットアップ  家のWi-Fiが見つからない！  家のルーターの設定で2.4GHzのアクセスポイントを無効にしていたのを思い出し2.4GHzに切り替え  電子レンジでよく切れた      ルーターとマイコンを結合  minicomの設定いじいじ  ハードウェアフローコントロールの解除(必須なのかは不明)  Arduino→minicomはできたけど逆ができなくて、その対処としてやった   minicom→Arduino  minicomは改行コードなしでキーを押した瞬間に送信(TeraTermと同じ) 改行コードを使ってコマンドをパースしてたので改行コードの有無に関係なくカンマとセミコロンでパースできるように変更。(これもロケットのコードから移植)   改行コード  CR+LFで送ると二行改行しちゃう CRで送ると改行するだけでカーソルが戻らないのでminicomでCRを有効化     HTTPを学ぶ curlからHTTP通信ができることを確認 pythonからUART叩いてモーター回すとこまでやった  8/10(3日目) サーバーサイドをサンプルコードで動かす  まずはREST APIはいじりたくなかったのでUARTの通信内容を書き換えて動作確認 curlで動作確認  フロントエンドもサンプルコードで動かす  まずはサンプルコードでボタンの動作確認 その後スライドバーでスロットルを直接動かす機能を実装  電源とかPWMとか  モーターをぶん回したらルーターの電源が落ちた  ちゃんと（？）制御をやってみる   ルーターの電源回路を観察  809RLと書かれた部品を発見  データーシート 電源電圧を監視してリセットをかける部品 下限電圧は2.63Vで意外と余裕があることが判明   レギュレーターのドロップアウト電圧を知りたかった  電源回路にインダクタがあったのでDCDCを組んでそう スイッチング用っぽい素子の詳細は不明   MCU自体の下限は2.97V  データシート   5Vから結構攻めて良さそうだったのでとりあえず3.3V+マージンで3.5Vを下限にした    CSSとの格闘  最低限はできたのでCSSと格闘  bootstrap何もわからん 全部vmで設定    複数端末の対応  ここらへんでREST APIをようやく理解 定期的にGETしてデータをもらう形式で実装 定期実行でアロー関数が使えないらしく、普通の関数に書き換え  理由は知らない 参考？   JSONのデコードに失敗してサーバーが落ちる不具合が発生  try-exceptで回避 プログラム終了時にシリアルを閉じる直前にモーター停止のフェイルセーフ    8/11(4日目) モーターが片方しか回らないバグの対処  オーバーロードしたら両方同時に出力を切るように変更  原因じゃなかった ずっと出力がおかしいから一時的な制御の問題じゃなくて通信の問題   ISR内部でのシリアル通信をやめた  通信を見ると明らかにUARTでの送信ができてなかった ISRでフラグ書き換え、メインループでフラグ監視方式 Serialが衝突しないから通信エラーがなくなった    GETの頻度を1Hzから2Hzに  ちゃんと動いた  発表資料の作成  Marpはいいぞ  8/12(5日目)  いろいろ発表  開発コース以外のイベント LT会 参加者交流としてLT会が設けられています。講師・チューターの方と、受講者の希望者が発表します。1日目のLTを見て自分も発表したくなり、さらにその日のグループワークのテーマ決めでCPU自作の話題が出たので4日目に4bit CPU自作について発表できました。ブログをMarkdownで書いておくとMarpで簡単にスライドにできるのでおすすめです。\nグループワーク セキュリティ・キャンプ終了後も、受講生同士で集まって好きなことができるようにグループワークが用意されています。自分のグループではRustの勉強会をすることになりました。他のチームではメンバーの興味がバラバラなため、さまざまな分野が協力できるCTFや分野指定なしのブログリレーなどをするところが多かった印象ですが、このチームでは全員Rustに興味があったのでRustを選択できました。\n完走した感想  とにかく楽しい  サンプルコードはあったけど2,3日で集中して作るのが楽しい discordでいろいろ話すのが楽しい   安定したハードを作るのが大事  ハードが信頼できないと上のレイヤーに上がれない（今回は電源）   基本情報/応用情報の勉強が役に立った  ネットワークとかHTTPとか、広く浅く知るのには良かった   手を動かす、大事  サンプルコードを参考に手を動かして独自の機能を実装するうちにHTTP通信を理解できた   勉強したいことが増えた  UARTとHTTPをMicroPythonで簡単に繋げられたので、中間の組み込みLinuxをやってみたい  終わったけどスタート感はある#seccamp\n\u0026mdash; 8bitマイコン (@771_8bit) August 12, 2022   ","description":"","id":2,"section":"blog","tags":["セキュリティ・キャンプ"],"title":"セキュリティ・キャンプ2022 X3 参加記","uri":"https://771-8bit.com/blog/seccamp-x3/"},{"content":"BME280の詳細なチューニングと設定ごとの精度や応答速度についてまとめました。BMP280でもほぼ同じように設定できます。\n環境 マイコンはArduino互換のSeeeduino XIAO、センサーは秋月電子のAE-BME280、ライブラリはAdafruitのものです。ボードのメーカーやライブラリが異なっても設定項目は同じです。\n設定項目 ライブラリに丸投げすればread()などの関数で値を読むことはできますが、用途ごとに精度や消費電力を最適化する場合やライブラリを自作する場合に必要な設定について簡単にまとめました。主にデータシートの3. Functional descriptionの内容です。\n測定モード BME280には2つの測定モード(3.3 Sensor modes)があります。\nForced Mode Forced Modeでは、マイコンからの命令により1サイクルだけ測定をしてマイコンに送信します。\nNormal Mode Normal Modeでは、常に測定を繰り返して値をセンサー内(出力レジスタ)に保存し、マイコンからの命令により最新の値を送信します。測定を繰り返す頻度は測定そのものにかかる時間($t_{measure}$)と待機時間($t_{standby}$)によって決まり、$t_{standby}$を明示的に指定します。\n測定の流れ BME280にオーバーサンプリングと内蔵IIRフィルタの機能があるため、\u0026ldquo;1サイクル\u0026quot;の測定が複雑になっています。センサーの出力レジスタの値が書き換わるのが\u0026quot;1サイクル\u0026quot;です。まずそれぞれ機能の説明をしたあと、測定の流れについてまとめ直します。\nオーバーサンプリング 1サイクルで温度・気圧・湿度をそれぞれ複数回測定して出力値を安定させることができます。測定回数はそれぞれ独立に設定でき、測定を省略することも可能です。\nIIRフィルタ オーバーサンプリングが1サイクル内で複数測定するのに対し、IIRフィルタは前のサイクルまでの値を使って出力値を安定させます。IIRフィルタは$filter_{coefficient}$という定数で設定します。この定数を用いて、前回の出力レジスタの値$data_{filtered-old}$と最新のセンサーの生の測定値$data_{ADC}$の加重平均を計算して新しい出力レジスタの値$data_{filtered}$とします。なお、$data_{ADC}$はオーバーサンプリング後の値です。\n$$ data_{filtered}=\\frac{data_{filtered-old}\\cdot (filter_{coefficient}-1)+data_{ADC}}{filter_{coefficient}} $$\n$filter_{coefficient}$は1,2,4,8,16が設定でき、1にすると式から明らかなようにIIRフィルタが無効になります。\n1サイクルの値をそのまま出力するわけではないのでノイズが減りますが、複数サイクルの値を使うので応答速度が下がります。この遅れはデータシートのFigure 7: Step response at different IIR filter settingsを参照してください。\n全体の流れと測定時間 Figure 6: BME280 measurement cycleの通りです。\n 測定開始 気温測定(オーバーサンプリング含む) 気圧測定(オーバーサンプリング含む) 湿度測定(オーバーサンプリング含む) 出力レジスタ更新(IIRフィルタ含む) 測定終了  測定時間$t_{measure}$はオーバーサンプリングをどの程度するかによって決まり、9.1 Measurement timeの通り計算できます。\nAdafruitライブラリでの設定方法 Adafruit_BME280.hのsetSamplingを用いることで設定を変更できます。引数の定数は同じファイルに列挙型で定義されています。\n221 222 223 224 225 226  void setSampling(sensor_mode mode = MODE_NORMAL, sensor_sampling tempSampling = SAMPLING_X16, sensor_sampling pressSampling = SAMPLING_X16, sensor_sampling humSampling = SAMPLING_X16, sensor_filter filter = FILTER_OFF, standby_duration duration = STANDBY_MS_0_5);   チューニング 編集中\n3.5 Recommended modes of operation\n","description":"","id":3,"section":"blog","tags":["電子工作"],"title":"BME280の詳細設定","uri":"https://771-8bit.com/blog/bme280/"},{"content":"セキュリティ・キャンプ2022のX3【ハードウェア魔改造ゼミ】に通過したので応募課題の回答を公開します。\n応募したコース 「電気回路からHTTPに至るまで全レイヤーに触れる」というところが楽しそうだったので、X3を第一希望にしました。X1とX4も課題の内容が被っていたため応募しておきました。\n X3【ハードウェア魔改造ゼミ】 X1【リバースエンジニアリングゼミ】 X4【無線通信ハッキングゼミ】  課題 セキュリティ・キャンプ全国大会2022 オンライン 開発コース X3【ハードウェア魔改造ゼミ】応募課題\n (1)以下の技術用語について解説してください。またどのようなところで使われているかも述べてください。わからない場合は調べて、自分なりに解釈した結果を述べてください。\n「オームの法則」「UART」「SPI(Serial Peripheral Interface)」\n(2)マイコンのファームウェアをデバッグするためには、どういう方法がありますか？\n(3)電気には直流と交流があります。同じ電圧のとき、どちらが感電したときに危険だと思いますか？その理由と一緒に説明して下さい。また感電はどんな工夫をすれば防げるでしょうか、思いつく限り多く挙げてください。\n(4)このデータシートから、以下の情報を読み取ってください。\nデータシートURL：\nhttps://datasheets.raspberrypi.com/rp2040/rp2040-datasheet.pdf\nrp2040-product-brief.pdf (raspberrypi.com)\n・GPIOに5.0Vを入力しようと思います。この機器は正常に動作しますか？\n・この機器でSPI通信は使用できますか？\n・IOVDDとDVDDの違いを説明してください\n・SWDポートを使うと何ができますか？\n・GPIO 1ポートから標準で何mA出力できますか？またGPIO合計で最大何mAまでの電流を出力できますか？(ただしQSPIポートで使用する電流は考慮しないものとします)\n(5)以下の質問に答えてください。\n・電波を発射する装置を日本国内で合法的に使用するには、「電波法で定められた基準に適合しているという証明」が得られた無線機が必要です。この証明の名前はなんですか？\n・市販されている無線ルーターの多くには、機能を完全に置き換えられる純正ではないファームウェアが存在します。非純正のファームウェアがインストールされた状態でWi-Fiを有効化すると、上記の証明が無効になり違法となる可能性があります。何を原因としてその可能性が生じるのか考察してください（簡潔な記述を望みます・400文字以内）。\n 回答 ※内容の正確性は保証できません\n(1)技術用語の解説 オームの法則 オームの法則は、回路に流れる電流Iが電圧Vに比例するという法則であり、V=RIと表されます。この比例定数Rを電気抵抗といいます。これは電磁気学の範囲では導出できない経験則で、導出する場合には物性物理の範囲に踏み込む必要があります。また、オームの法則に従わない非線形素子も存在し、半導体はまさに非線形素子です。\nオームの法則なしに電気回路について考えることはできません。単純な例として、LEDの保護抵抗を計算するためにもオームの法則は必要です。定格の電流を流すため、電源電圧からLEDの電圧降下を引いた電位差を定格電流で割ることにより保護抵抗を求めます。この抵抗を直列にLEDに接続することでLEDに定格電流を流すことができます。\nUART UARTはUniversal Asynchronous Receiver/Transmitterの略で、2つのデバイスの間でシリアル通信を行うプロトコルです。\nシリアル通信は、複数の信号線を用いてデータをまとめて送受信するパラレル通信に対して、データを1bitずつ順に送受信する通信方式です。組み込み用途で使われるシリアル通信としては、UART・SPI・I2Cが有名です。\nシリアル通信には、1対多で通信できるものもありますが、UARTは1対1の通信で、マスター(親機)・スレーブ(子機)の区別はありません。\nUARTでは基本的には送信用のTXと受信用のRXという信号線のみで通信します。片方機器のTXをもう片方の機器のRXに繋いでデータを送ることができます。基本的には互いにTXとRXを接続する全二重通信を行いますが、一方向通信で良いときは片方のTXと片方のRXだけを接続した単向通信も可能です。また、フロー制御を行うためCTSやRTSといった信号線を接続することもありますが、あまり一般的ではありません。\nUARTのAはAsynchronousの頭文字で、クロックを使用しない非同期式という意味です。予め決めた速度でTXからビット列を送信し、その速度でRXから読み出してデータをやりとりします。クロック線に同期して信号をやりとりするものは、USART(Universal Synchronous Asynchronous Receiver/Transmitter)といいます。\nUARTはデータはパケットに分割して送受信されます。パケットはスタートビット・データビット・パリティビット・ストップビットで構成されます。通信の開始と停止を示すのがスタートビットとストップビットです。データビットが実際に通信したい内容であり、5～9ビットが使用できますが7～8ビットが一般的です。パリティビットは通信内容に誤りがないか確認するためのビットです。データビットの長さ・パリティビットの詳細・ストップビットの長さは、通信速度とともに使用する機器同士で共有しておく必要があります。\nUARTは1対多ではなく1対1の通信となるため、マイコン間での通信や、マイコンとパソコンとの通信・マイコンと通信モジュールとの通信に用いられることが多いです。通信が高速なSPIや電気的にやや不安定なI2Cが同じ基板内のデバイス同士での通信に使用されるのに対し、UARTは異なる機器同士での通信も可能であり、差動伝送に変換すればより長距離での通信が可能となります。\nSPI(Serial Peripheral Interface) SPIはSerial Peripheral Interfaceの略で、1対多でシリアル通信を行うプロトコルです。\n一つのマスター(親機)がバス全体を制御します。チップセレクト(CS)・スレーブセレクト(SS)などと呼ばれる線を用いて通信相手となる子機を選択して通信します。デイジーチェーン接続も規格上可能ではありますが、あまり一般的ではありません。\n信号線には、マスター出力/スレーブ入力のMOSI・マスター入力/スレーブ出力のMISO・クロックのSCLKがあります。MOSIとMISOが独立しているので送受信を同時に行う全二重通信です。マスターから選択されていないスレーブのMISOはハイインピーダンスとなるので影響を与えません。\nSPIはクロックを用いた同期通信で、比較的高速な通信が可能です。クロックには、アイドル時にHにするかLにするかを指定する極性(CPOL)と、データのサンプリングを立ち上がりにするか立ち下がりにするかを指定する位相(CPHA)の設定があり、マスターとスレーブで一致させておく必要があります。\n通信の開始・停止はCS(SS)で行うので通信するパケットに特にルールはないですが、8bitごとに通信するのが一般的です。\nSPIは比較的高速に1対多の通信が行えるので、センサーなどの周辺機器とマイコンとの通信に利用されます。また、SDカードもSPI通信で使用することができます。\n(2)マイコンのファームウェアのデバッグの方法 デバッグツールとしては、ICE、ROMエミュレータ、OCD、デバッグモニターがあります。MPUと差し替えて使用し、MPUがどう動作するかエミュレートするのがICE(In-Circuit Emulator)です。MPUごとにMPUよりも複雑なICEを開発する必要があるため非常に高価であり、今は主流ではありません。プログラムを動作させるMPUではなくプログラムを格納するROMを差し替えて動作中のROMの様子を調べるのがROMエミュレータです。マイコンにROMが内蔵されるようになったため、これも主流ではありません。現在一般的に使われているのはOCD(On-chip Debug)です。デバッグしたいマイコン自身がもつデバッグ用の機能を外部から利用するもので、JTAGやSWDといった規格が有名です。デバッグモニターはマイコンとPCなどを接続し、マイコンのソフトウェアからシリアル通信などで必要なデータを送信するものです。単純なLチカデバッグやprintfデバッグもデバッグモニターといえます。\nOCDを使うと、プログラムを一つずつ実行したり、マイコン内部の様々な状態を取得したり、高度なデバッグができる。デバッグモニタではソフトウェアで書いた少ないデータしか読み取れませんが、簡単にデバッグができます。\nこのようなデバッグツールを使った上で、バグを洗い出し、さらにバグの原因を特定して修正する必要があります。バグの洗い出しでは、細かいモジュールごとにテストを繰り返して早期にバグを発見することが重要です。テストには、機能仕様に基づいたブラックボックステストや、プログラムの内部実装に基づいたホワイトボックステストがあります。\nテストで見つけたバグの原因を特定するときは、プログラムが動作する理由をしっかり理解したうえで、その仕組みを小さな構成要素に切り分けて一つずつ調べていきます。切り分けた各部分について、デバッグツールを用いて想定通り動作しているか調べたり、条件を変えて調べたりして原因を特定し修正していきます。\n(3)感電とその対策 交流の方が危険です。同じ電圧(実効値)のときは発生するジュール熱は同じなので火傷のリスクは同じになると考えられます。しかし、人間の筋肉は電気信号に従って動いていて、直流では筋肉が硬直するのに対し、交流では筋肉が痙攣します。交流で感電した場合は心室細動がおきる可能性があり致命的です。\n感電対策として、電子機器を使うときは、漏電遮断機を使用すること、アースを接地すること、コンセントにカバーをすること、劣化した電子機器を使用しないこと、濡れた手で電子機器を触らないことに気をつけます。さらに、電子機器を作ったりメンテナンスしたりする場合には、絶縁工具を使用すること、保護具を着用すること、活線作業は原則として行わなわず、検電器で確認すること、電線は一本ずつ扱うこと、導体部を露出させないことに気をつけます。\n(4)データシートの読み取り 入力電圧 5.2.3.1. Absolute Maximum RatingsのVoltage at IOはIOVDD + 0.5 Vとなっていて、IOVDDの上限は3.63Vであるため正常に動作しません。また、tolerantという単語でデータシート内を検索するとFault Tolerant Digitalという機能が見つかりますが、これは5V tolerantではありません。\nSPI通信 4.4. SPIから分かるように、2系統のSPI通信がマスタースレーブどちらでも使用できます。\nIOVDDとDVDDの違い 1.4.2. Pin Descriptionsにあるように、IOVDDはデジタル入出力ピンの電源であり、DVDDは内部のコアの電源です。Figure 2. A system overview of the RP2040 chipにおいて、IOsのみを駆動するのがIOVDDであり、USBやADCなどの例外を除いた内部回路を駆動するのがDVDDです。\nSWDポート SWDはSerial Wire Debugの略で、マイコンのデバッグができます。2.3.4. Debugにあるように、具体的には以下のことが可能です。\n 本来主記憶装置として使われる揮発性のSRAMや、外部のフラッシュメモリへのファームウェアの格納 プロセッサの動作を手動で進めたり、動作状況を確認したりすること メモリやIOの状態の確認  出力電流 2.19.4. Padsからわかるように、1ポートからは最大12mAを出力できます。ただし、Table 621. Pin Typesからわかるようにデフォルトでは4mAで、Table 351. GPIO0,GPIO1,…,GPIO28,GPIO29 Registersのようにレジスタを書き換えることで設定を変更できます。\n5.2.3.4. IO Electrical CharacteristicsのMaximum Total IOVDD currentから、合計で50mA出力できると分かります。なお、吐き出し(sorce)電流がIOVDD currentで吸い込み(sink)電流がVSS currentで、RP2040ではどちらも50mAで同じです。\n(5)技術基準適合証明 無線通信に関係しないソフトウェアを変更することは問題ないですが、そのファームウェアが無線通信を担っている場合には違法となる可能性があります。技適のある無線ルーターのハードウェアを用いても、ソフトウェアによって無線通信の電波強度や周波数帯、送信休止時間などが変更できる場合は電波法で定められた基準に適合しなくなる可能性があるからです。この場合はハードウェアの改造と同じように扱われ、技適が無効となり違法となります。例えば、WiFiモジュールESP-WROOM-02はソフトウェアを書き換えることができますが、専用のライブラリやSDKを使っている限りでは無線通信の仕様には関係ない部分のソフトウェアを書くことになるため、認証には影響はありません。しかし、SDRに関わるソフトウェアを変更する場合には違法となる可能性があると考えられます。　(366字)\n","description":"","id":4,"section":"blog","tags":["セキュリティ・キャンプ"],"title":"セキュリティ・キャンプ2022 X3 応募課題晒し","uri":"https://771-8bit.com/blog/seccamp-assignment/"},{"content":"DashWareというソフトウェアを使い、自作ロガーで取得したデータを動画にオーバーレイ表示する方法をまとめました。\nDashWareとは DashWareは、ロガーで取得したデータを動画にオーバーレイ表示できるソフトウェアです。車・自転車・ドローンなどレースの編集によく使われているようですが、鳥人間コンテストやハイブリッドロケットの動画編集でも便利だと思います。\nネットには既製品のロガーでの使い方はありましたが、自作ロガーへの対応はほぼ手探りで調べたことをまとめたので間違いがあるかもしれません。\nDashWareの使い方 インストール 公式サイトからダウンロードできます。\nプロジェクトの作成 File -\u0026gt; New Projectより、新しいプロジェクトを作成します。Project Templateはデフォルトで表示されるゲージの設定だけなので\u0026lt;None\u0026gt;で問題ありません。\n動画の読み込み 以下のように動画を読み込みます。\nデータの読み込み 同様にデータを読み込みます。\nここからEdit ProfilesをクリックしてData Profileの設定に移ります。\nData Profileの作成 Data Profileを設定することで自作ロガーに対応させます。この記事の本題です。\nここでDashWare Loggerをクローンして自作ロガー用のプロファイルを作成します。名前はMy Loggerにしました。\nCSVのフォーマット 自作ロガーからデータをCSVで吐き出し、Separator Settingで設定した区切り文字、Decimal Formatで設定した小数点にフォーマットを合わせます。\n1行目にはHeader Lineなるものが必須のようで、\u0026ldquo;hello\u0026quot;など適当な文字列を置いておく必要があります。\nCSVファイルは以下のようになります。\n \u0026ldquo;hello\u0026rdquo;\n\u0026ldquo;Time\u0026rdquo;,\u0026ldquo;Elevation Meters\u0026rdquo;\n0,-0.3609\n0.1,-0.3809\n0.2,-0.4609\n0.3,-0.4609\n\u0026hellip;\n データ名の対応 2行目に指定するデータ名は、Column Mappingsで指定します。Column Mappingsの行をダブルクリックし、Data Column Mapping Editorを開きます。\nInput ColumnのInput Data ColumnでCSVファイルに書いたデータ名を指定します。ドロップダウンリストではなくコンボボックスなので好きな文字列を入力できます。ラジオボタンは文字列を含むか完全に一致するかどちらでデータを取り込むかの選択です。CSVファイルでデータ名はダブルクォーテーションをつけることに注意してください。\nColumn Mappingでは、取り込んだデータをDashWare内でなんという名前で扱うかを指定します。カテゴリーとその中の種類を指定するようになっていて、選択肢にないものは選べません。\n時間の設定 時間をもとに動画と同期させるので\u0026quot;Time\u0026quot;は\u0026lt;Required\u0026gt;となっていて必須です。CSVファイルの\u0026quot;Time\u0026quot;の列を時間として読み取ります。単位は秒で正の数しか受け付けません。\nカウントダウンを含む場合など、負の時間を含む場合はこれとは別にデータ列を用意します。\nゲージの設定 Guage ToolBoxから好きなゲージを動画の部分にドラッグアンドドロップして追加します。\nこれをダブルクリックすると詳細な設定が可能ですが、基本的にはColumn Mappingでカテゴリーとデータの種類を適切に設定していれば設定を変更する必要はありません。\n同期 Synchronizationを開いて動画とデータの同期を行います。この操作に関しては公式のチュートリアル動画の0:45以降が分かりやすいです。\n書き出し File -\u0026gt; Create Videoから完成した動画を書き出せます。\n作成例    ハイブリッドロケットの打ち上げの動画をDashWareを使って編集しました。この詳細は別の記事に書きました。\n","description":"","id":5,"section":"blog","tags":["ロケット","鳥人間","ドローン","電子工作"],"title":"【DashWare】自作ロガーのデータを動画にオーバーレイ","uri":"https://771-8bit.com/blog/dashware/"},{"content":"第20回伊豆大島共同打上実験に参加し、自作ロケットを打ち上げました。\n伊豆大島共同打上実験は、全国の大学生によるハイブリッドロケットの打上実験です。私はCOREのメンバーとして参加しました。COREはハイブリッドロケットの製作・打上げを行う関東圏のインカレです。打ち上げたロケットCANVASは新入生が中心となって製作を行い、私は電装部分を担当しました。\n   打ち上げの様子とロケットのノーズに搭載したカメラの映像、取得したデータをまとめました(DashWareを使用)。\nロケットの詳細は報告書として共同打上実験のHPに公開しています。以下に公開する事柄はこの報告書に全て記述されています。\nこのミッションでは新入生教育を背景として、基礎的なロケットを作ることを目標としました。電装系としては、頂点で開放機構を動作させることとセンサーとカメラのデータを回収することが目標でした。機能としてはシンプルなため一つのマイコンで制御可能ですが、確実に動作する電装を作り、その開発体制をこれから維持できる基盤を作るため、CAN通信を採用したのが今回の電装の特徴です。CAN通信の具体的なメリットは報告書にまとめました。特に、COREはインカレであるためCANでモジュールを分割することにより開発を分担しやすくなりました。CANを使用した以外にも、通信の途絶やモジュールの故障、アップリンクやプログラム書き込みでの操作ミスなど様々なリスクを考慮し、動作テストを繰り返して信頼性を高めました。\n打ち上げ当日は問題なく電装は動作し、パラシュートの開傘とデータの回収に成功しました。取得したデータの詳細は報告書にあります。\n   打ち上げ時の地上局の録画\nハイブリッドロケットの電装は機能としてはシンプルで高度な制御は行っていませんが、本番一回の打ち上げで確実に動作させるという点に難しさと楽しさがあると思っています。打ち上げと全く同じ状況を地上で再現することはできないため、様々なことを考えて設計・製作をする必要があります。打ち上げ時はとても緊張し、パラシュートが開いたときは手が震えるほど嬉しかったです。これからもこの分野でのものづくりを続けていきます。\n","description":"","id":6,"section":"blog","tags":["ロケット"],"title":"第20回伊豆大島共同打上実験","uri":"https://771-8bit.com/blog/izuoshimarocket-20/"},{"content":"pyserialとPySimpleGUIを使ってシリアルモニタを作りました。ArduinoをGUIで操作できます。\n使用したライブラリ pyserial pyserialを使うとPythonでシリアル通信を行えます。これだけでArduinoとの通信は可能ですが、今回はGUIにするためPySimpleGUIも使用しました。\nPySimpleGUI PySimpleGUIはPythonでGUIを扱うためのライブラリで、tkinter・Qt・WxPython・Remiといった既存のライブラリをまとめて簡単にコードを書けるようにしたものです。学習コストをかけずサクッとGUIアプリを作りたい場合は、簡単に書けるPythonとこのライブラリの組み合わせが最適だと思います。\nシリアルモニタ このようなシリアルモニタを自作できます。\nコード全体をのせます。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68  import PySimpleGUI as sg import serial import serial.tools.list_ports import time import threading coms = serial.tools.list_ports.comports() comlist = [] for com in coms: comlist.append(str(com.device)) sg.theme(\u0026#39;DarkBlack\u0026#39;) layout = [[sg.Text(\u0026#39;COMポート\u0026#39;),sg.Combo(comlist, size=(10, 1),key=\u0026#39;selectCOM\u0026#39;, enable_events=True),sg.Text(\u0026#39;\u0026#39;,size=(16, 1),key=\u0026#39;com_state\u0026#39;),sg.InputText(\u0026#39;\u0026#39;, size=(18, 1), key=\u0026#39;uplink\u0026#39;),sg.Button(\u0026#39;送信\u0026#39;, key=\u0026#39;send\u0026#39;)], [sg.Output(size=(97,10))] ] window = sg.Window(\u0026#39;Serial Monitor\u0026#39;, layout,enable_close_attempted_event=True) ser = serial.Serial() ser.baudrate = 115200 ser.timeout = 0.1 def GUIloop(): while True: event, values = window.read() if event == \u0026#34;-WINDOW CLOSE ATTEMPTED-\u0026#34;: if(sg.popup_ok_cancel(\u0026#34;終了しますか？\u0026#34;)==\u0026#39;OK\u0026#39;): ser.close() window.close() break if event == sg.WIN_CLOSED: #ウィンドウのXボタンを押したときの処理 break if event == \u0026#39;selectCOM\u0026#39;: if ser.is_open: ser.close() ser.port = values[\u0026#39;selectCOM\u0026#39;] ser.open() if event == \u0026#39;send\u0026#39;: try: ser.write(values[\u0026#39;uplink\u0026#39;].encode()) window[\u0026#39;uplink\u0026#39;].update(\u0026#39;\u0026#39;) except: print(\u0026#39;err\u0026#39;) def COMloop(): while True: if ser.is_open: window[\u0026#39;com_state\u0026#39;].update(\u0026#39;connected\u0026#39;) try: text=ser.readline().decode(\u0026#39;UTF-8\u0026#39;).rstrip() print(text) except: time.sleep(0.1) else: window[\u0026#39;com_state\u0026#39;].update(\u0026#39;disconnected\u0026#39;) time.sleep(0.1) thread_GUI = threading.Thread(target=GUIloop) thread_COM = threading.Thread(target=COMloop, daemon=True) thread_GUI.start() time.sleep(0.5) thread_COM.start() time.sleep(1)   PySimpleGUI PySimpleGUIについては以下の記事を参考にしました。\n Pythonでも簡単にGUIは作れる  ドロップダウンリストを利用したCOMポートの選択 pyserialの機能で使用可能なCOMポートをlistで受け取れます。この要素を文字列に変換してPySimpleGUIのコンボボックスに追加しています。valuesを通して選択された文字列が受け取れるので、これをもとにCOMポートを開くことができます。\n PySimpleGUIを使ったドロップダウンリストの作成方法について PysimpleGui コンボボックスを動的に変化させる方法  pyserialでの文字列の送受信 文字列ではなくバイナリデータとしてシリアル通信を行うので、送信時は'文字列'.encode()とする必要があります。逆に受信時はser.readline().decode('UTF-8')とします。このプログラムではさらにrstrip()を使いました。\n 【TIPS】Pythonでシリアル通信するpyserialの使い方と動作確認方法[Windows版] Pythonで文字列の前にBをつける  GUI用スレッドとCOMポート用スレッドの処理 GUI用ループとCOMポート用ループを別で走らせるためにデーモンを使用しました。\n Pythonのthreading使ったらプログラムが止まらなかったパターンがある 【Python】スレッドのデーモン化について  応用 これを応用して少し込み入ったGUIも実装できます。これはハイブリッドロケットの地上局のソフトウェアです。この詳細は別の記事に書きました。\n  ","description":"","id":7,"section":"blog","tags":["電子工作","Python"],"title":"pyserialとPySimpleGUIでシリアルモニタ","uri":"https://771-8bit.com/blog/pyserial/"},{"content":"【Lチカの先へ】データシートを読んでセンサーをArduinoで使えるようになる最短ルートとしてelchikaに投稿したものの最新版です。\nはじめに センサーの専用ライブラリに頼らず「データシートを読んでセンサーをArduinoで使える」人が、初心者を同じレベルまで電子工作ができるように教育することを想定しています。Lチカまではたくさん資料があるけど、そこから先はどうすれば…と思って自分のメモとして書きました。そのため、初心者の人がこれを読んで自力で学ぶには不親切かもしれません。目標のセンサーは秋月のセンサーモジュールぐらいのつもりです。\n質の高い書籍や資料は存在しますが、何か一つの資料だけで完璧に習得できるということはまずなく、完璧な入門書を使うとその先が分からなくなるということもあるので、様々な資料を使いながら電子工作に慣れていくというのが良いかなと思います。その主軸として、特に以下のことを考えてこのプランを作りました。\n 本やネットの内容をコピーするのではなく、自分でものを作れること 問題を解決する能力をつけること、問題を回避する能力をつけること 自分でさらに知識をつけることができる基盤を作ること  やること やることを順番にまとめて、学べることを箇条書きにしました。マイコンはSeeeduino XIAOを想定しています。\n魚ではなく魚の釣り方を教えるイメージで以下の通りにすれば、電子工作がある程度できるようになると思います。\nチカチカ チカチカ(非安定マルチバイブレータ)を回路図を読んで作ります。できればコンデンサや抵抗を変えて周期の変化を確かめたり、波形をオシロで見せつつ仕組みの解説をしたいところです。\n 回路図の読み方 ブレッドボードの使い方 電子回路  LEDと保護抵抗 コンデンサ(RC回路) トランジスタのスイッチング   はんだ付け  Lチカ まずはLチカでArduinoの基本的な使い方を学びます。プログラミングも初心者の場合はここからゆっくりプログラミングについて教えます。\n Arduino IDEの使い方 デジタル出力  スイッチでLEDのON/OFF スイッチを押したらLEDが光るようにします。\n デジタル入力 プルアップ・プルダウン  PCとシリアル通信 スイッチが押されたらPCにシリアル通信をするプログラムを書きます。printデバッグ用に早めにこれをやると良いかなと思います。押されている間ずっと通信するのではなく押された瞬間に通信するプログラムにします。\n PCとのシリアル通信 スイッチのチャタリング  可変抵抗でLEDの明るさ調整 可変抵抗で分圧回路を作り、それをADCで読み取ってLEDの明るさを調整します。LEDの降下電圧を確認するため、DAC→PWMの順で実践します。PWMの出力波形をオシロで見せられると良いです。\n 分圧 ADC DAC PWM (analogWrite)  Seeeduino XIAOのADC(analogRead)はすべてのピンで10bit、analogWriteは0番ピンのみDACでデフォルトは10bit、それ以外のピンはPWMでデューティー比は8bitで設定できます。詳細はこちらの記事を参照してください。\n圧電ブザー LEDだけだとつまらないので音を出してみます。まずは単純にONOFFを繰り返すプログラムを書いてPWMについて理解したあと、tone関数を使ってみると良いと思います。圧電ブザーはミニゲームでも活用できます。\n PWM  サーボモータ PWMを素直に書いたあと、Servoライブラリを導入すればライブラリについても学べます。\n PWM ライブラリ  スイッチでLEDの点灯/点滅 複数のセンサーや周辺機器を制御することを想定して、あるLEDを一定周期で点滅させつつ、別のLEDのON/OFFをスイッチで切り替えられるようにします。まずはタイマや割り込みを使わないでプログラムを組んで、delay中はスイッチの判定ができないことを確認します。タイマと割り込みについて解説した後、以下のような方法で実装します。\n delayで点滅し、割り込みでスイッチを監視する方法 delayで点滅し、ピン変化割込みでスイッチを監視する方法 タイマ割り込みで点滅し、loopでスイッチを監視する方法 時間関数を使って点滅し、loopでスイッチを監視する方法  Seeeduino XIAOのタイマ割り込みは、Arduino IDEのスケッチ例を参考にしてください。ピン変化割り込みでは、ピンの番号に注意してください。\nこのように割り込みには様々な使い方がありますが、以下の方針で使う方法を選ぶと良いと思います。\n 優先度の高いタスクを割り込みで実行する 割り込みルーチンの実行時間を短くする プログラム全体でdelay関数を使わないでいいようにする  学ぶのは以下の内容です。\n タイマ 割り込み  LEDとスイッチでミニゲーム 数個のLEDとスイッチのセットで作れるミニゲームを実装します。光ったLEDに当たるスイッチを制限時間内に押すモグラ叩きゲームがちょうど良いと思います。これに圧電ブザーを加えてみても良いです。ここでじっくり自力で仕様を考えてプログラムを組んでデバッグすることが重要です。\n 変数や制御文などの\u0026quot;プログラム\u0026quot; デバッグ  部品を壊す 予期しないタイミングで部品を壊してしまうよりは、一度簡単な部品を壊す経験をしてしまう方が安全だと思います。その経験としてLEDを保護抵抗無しで電源(保護回路あり)に直接つなげます。電解コンデンサの逆接は危険ですが、LEDの破壊程度であれば何かカバーを被せれば十分安全に試せると思います。\n 絶対最大定格 故障モード\nLEDの破壊の様子はYouTube等で見ることができます。実験の前に動画を見て危険だと思われる場合は、LEDの破壊の代わりに適切な抵抗を挟んだうえでヒューズを溶断してみるのをおすすめします。   センサ(ADC) いきなりシリアル通信は難しいので、ADCで読めるセンサを使います。\n データシートの読み方  センサ(シリアル通信) シリアル通信(ArduinoのSerial(UART)に限らず)で読めるセンサを使います。Arduinoのコードをなんとなく追うのではなく、まずシリアル通信のプロトコルについてしっかり理解して、どんな信号がやりとりされているのかを把握するべきです。その後Arduinoの関数の役割を理解すれば詰まることなく進められるはずです。\n シリアル通信  使う部品・サンプルコード  サンプルコードはGitHubで公開しています。Seeeduino XIAOを使うことを想定しています。\n必要な知識・スキル 知識そのものを自分で書くと時間が足りないので、いい感じの資料をまとめました。もちろん全部覚えてもらうことはないです。\nほぼ全ての基礎\n電子工作のための電子回路基礎\nArduinoをはじめよう 第3版\n組込みエンジニアの教科書\n実際の製作  はんだ付け\nまずはこれ(村田製作所)\n細かいこと1(HAKKO)\n細かいこと2(GodHanda) ブレッドボードの使い方  プログラミング  C++入門 AtCoder Programming Guide for beginners 苦しんで覚えるC言語  Arduino・マイコン 公式Arduinoリファレンス\ngarretlab\nNOBのArduino日記！\nspiceman\n そもそもコンピュータ・マイコンとは\nDigikey(動画)\nそもそも「マイコン」って何？ マイコンやセンサーを動かすための外部の回路  電源(レギュレータ・コンデンサなど) プルアップ・プルダウン   マイコンの機能  入出力 ADC DAC タイマ PWM 割り込み シリアル通信  UART SPI I2C      一般の回路・部品  Electrical Information\nマイコン以外の電子部品、電気・電子回路 秋月のカタログ\n使える武器が増えるのでどんなカテゴリがあるか知っておいた方が良いです。  単純な技術以外のスキル 問題解決・問題回避 もの作りで一番必要なのは失敗が許容される状況だと思います。無計画でいいというわけではなく、大きな失敗を避けること、失敗してもそれを解決できることが重要です。(チームの場合は人間関係がゴタゴタしないことも重要)\n 問題回避\n最初から完璧を目指して全部作って最後に動作確認をすると、問題の原因特定が困難です。ある程度の機能を作ったら動作テストを心がけ、細かい失敗を前提とした製作をします。Done is better than perfect. 問題解決\n経験があれば問題から直接原因を推測したり、よく観察してすぐに原因を特定できたりしますが、慣れないうちは以下の手順を丁寧に行うことをおすすめします。  分割する\n動かない理由を特定するには、当然ですが動く理由をしっかり理解していることが必要です。そのうえで、仕組みを小さな構成要素に切り分けて一つずつ調べていきます。仕組みの最初から最後まで順番に調べていくのは手間が手間がかかり、どの程度細かく分割すればいいか分からなくなるので、二分探索の要領で進めていくと良いです。 チェックする\n切り分けた各部分について、以下の方法で問題ないか調べていきます。\nA 想定通り動作しているか調べる\nB 条件を変えて調べてみる(対照実験) 分からないことはググる/人に聞く\n質問の仕方     LEDが光らないなら、まずマイコン側と回路側で分割します。テスターを使ってマイコンから正しい電圧が出ていることが分かれば(A)、問題は回路側にあることになります。LEDが故障しているなら、LEDを交換する(B)ことで原因にたどり着くはずです。これは単純な例ですが、複雑な問題も同じように解決できます。\n データシートの読み方 読んで慣れるしかない？\nなにかアドバイスあればコメントください。\n公式ドキュメントの扱い方 公式サイトと他のサイトはそれぞれどちらも長所短所があるので、使い分けを意識します。\n 他のサイトを見て全体像を把握する 公式サイトにたどり着く まずサイトの構成を知る 必要な所を読む   公式ドキュメント(公式リファレンスとも)\nその技術や製品そのものについて書いてある\nそれの仕様,使い方をちゃんと学べる 信頼性が最も高い(外部サイトは情報が古いかも) 他のサイト  それを外部の視点から書いたもの\n他の技術や製品と比べて書いてある 外から見るので全体像が掴める 公式に書いてないことを書いたもの\nバグは外部サイトに書いてある事が多い 公式の記述を要約しているもの\n分かりやすいけど結局公式のトップページが神    おすすめの工具・測定器 おすすめの工具・測定器を布教して終わりにします。\n はんだごて FX600 こて台 633-01 こて先 2.4D型 T18-D24 ハンダ吸取器 SS-02   はんだ吸煙器 オシロスコープ HDS2102S ","description":"","id":8,"section":"blog","tags":["電子工作","Arduino"],"title":"電子工作入門","uri":"https://771-8bit.com/blog/for-beginners/"},{"content":"「CPUの創りかた」のTD4を製作しました。製作時点で購入できた部品についてまとめてあります。\n作ったもの ロジックICで自作する4bit CPUを「CPUの創りかた」をもとに作りました。集積度が高いのが好きなので、秋月電子のユニバーサル基板のBタイプに収めてあります。実際に作ってデバッグしていくとCPU内のデータの流れがよく理解できました\nデバッグしやすいように動作確認がとれる部分ごとに製作していきました。\n ROMを作って単体で動作確認 クロック回路を作って単体で動作確認 命令デコーダを作ってROMとクロック回路をつなげて動作確認 残りをすべて実装して完成  ROM TD4のオリジナルの回路に加えて、実行中の命令を示すLEDをつけました。ダイオードはカソードコモンのダイオードアレイを使っています。使用したDIPスイッチは幅が狭く実装密度を上げたい場合はおすすめです。\nTD4のROM\n(74HC540買い忘れ) pic.twitter.com/1vrP5s8ATu\n\u0026mdash; 8bitマイコン (@771_8bit) September 19, 2021 普通のDIPパッケージの部品を使うときもハーフピッチ基板を使うとピンの隙間に配線を通せて便利です。\nクロック回路 ICの電源ピンからクリップで電源を供給して動作確認しました。\nTD4のクロック回路(と自作オシロ) pic.twitter.com/CvYocwevLy\n\u0026mdash; 8bitマイコン (@771_8bit) September 20, 2021 命令デコーダ 同じ種類のゲートを入れ替えて配線が簡単になっています。\n動作テスト pic.twitter.com/JgnaEWmPwb\n\u0026mdash; 8bitマイコン (@771_8bit) September 20, 2021 CPU中心部 74HC161はSOPパッケージのものしか入手できなかったのですが、ICの裏に配線を通したかったので変換基板を使って表側に実装しました。レジスタAとレジスタBの値を青色LEDで示せるようになっています。出力レジスタは出力のLEDで、プログラムカウンタはROMの緑色LEDで確認できます。\nTD4完成！ pic.twitter.com/Sthn8hqvNx\n\u0026mdash; 8bitマイコン (@771_8bit) September 23, 2021  主要部品購入先 74HC154は入手できなかったため、こちらの記事を参考に74HC138で置き換えました。3-to-8デコーダを2つ使って4-to-16デコーダを作ります。\n   オリジナル  用途 型番 購入先     74HC74 キャリーフラグ TC74HC74AP (フリッププロップ) 秋月   74HC161 レジスタ・プログラムカウンタ TC74HC161AF (4ビットカウンタ) 秋月   74HC153 データセレクタ TC74HC153AP (4chマルチプレクサ) 秋月 マルツ   74HC32 命令デコーダ TC74HC32AP (OR) 秋月   74HC283 ALU CD74HC283E (加算器) 千石   74HC10 命令デコーダ TC74HC10AP (NAND) 千石   74HC154 アドレスセレクタ TC74HC138AP (3-to-8ラインデコーダ) 秋月   74HC540 アドレス出力 TC74HC540AP (インバータ) 千石   74HC14 クロック回路 TC74HC14AP (シュミットトリガ) 秋月   DIPスイッチ ROM KSD82 (DIPスイッチ 8P) 秋月   ダイオード ROM CE880 (ダイオードアレイ) 秋月    詰まったところ カウンタICの使い方 TD4ではカウンタICのカウントアップ機能を殺してレジスタを作ります。最初はこのあたりをよく理解せずに配線を始めていて、74HC161のENTピンとENPピンをLに落としていませんでした。このため電源を入れるとレジスタAとBが勝手にカウントアップしました。加算回路を調べても正常だったので本を読み直すとICのカウントアップ機能が原因だったことが分かりました。\nプルアップ配線ミス スイッチのプルアップ抵抗を電源側ではなくスイッチ側につけてしまいました。これは実装した翌日に基板を見て気づきました。製作物も製作者も一晩寝かすとデバッグが進みますよね。\nはんだ付け接触不良 レジスタAが常にロードされるような挙動から、レジスタAの74HC161の接触不良に気づきました。\nセキュキャンのLT会資料 セキュリティ・キャンプ全国大会2022のLT会でTD4について発表しました。\nロジックICから4bit CPUを作る by @771_8bit","description":"","id":9,"section":"blog","tags":["電子工作"],"title":"TD4作ってみた","uri":"https://771-8bit.com/blog/td4/"},{"content":"秋月電子で取り扱いの始まったCO2センサーMH-Z19CをArduino Nano Everyで使ってみました。\nこの記事はQiitaに投稿した記事を再掲したものです。\nMH-Z19Cについて MH-Z19CはNDIR方式のCO2センサで、電源電圧は5.0±0.1V、データの出力はPWMかUART(3.3Vで5.0Vにも対応)です。測定できる範囲はPWMを使うと公称値は400~2000ppm(実測では400~5000ppm)、UARTでは400~5000ppmです(CO2濃度は大気中で約400ppm、室内で約1000ppm、呼気で約30000ppmが目安)。ピンヘッダは2.54mmピッチですが、ピンヘッダとピンヘッダとの間隔が合わずユニバーサル基板に挿すのは難しいので注意してください。\nここでは5V駆動のArduino Nano Everyを使い、PWMとUART両方のデータを読んでみます。\nハードウェア 使ったもの  MH-Z19C Arduino Nano Every 5Ｖ出力昇圧DCDCコンバーターとコンデンサー  Arduinoの5V OUTピンの電圧を測ると4.72-4.78Vでセンサーの電圧の範囲から外れていたので、一応4.9~5.1V出力(実測4.98V)のDCDCコンバーターと100μFのコンデンサーをつけました。\n接続    MH-Z19C      Vin DCDCコンバーター ← Arduino 3.3V   GND Arduino GND   PWM Arduino A7   Hd Arduino A6   Rx Arduino TX1   Tx Arduino RX1    ソフトウェア MH-Z19Cの仕様 データシートはここで読めます。以下の画像はデータシートのものです。\nUART UARTでCO2濃度の読み取りと自動キャリブレーションの設定ができます。\nPWM データシートでは上のようになっていますが、Cppm=5*(パルス幅[ms]-1.2)とするとUARTと同じデータが読み込めました。Arduino Nano EveryのpulseInかセンサーのPWM出力のどちらかが原因だと思います。\n手動キャリブレーションはHdピンを使うのでPWMでもできますが、自動キャリブレーションの設定はPWMだけではできません。デフォルトでは24時間ごとに自動キャリブレーションが行われます。(キャリブレーション時にどんな濃度でもそれを400ppmと認識するのではなく、24時間経ったあたりで400ppmに近い状態と判断するとキャリブレーションを行うようです)\nプログラム 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50  uint16_t uartco2; unsigned long pwmco2; bool reset = false; byte ReadCO2[9] = {0xFF, 0x01, 0x86, 0x00, 0x00, 0x00, 0x00, 0x00, 0x79}; byte SelfCalOn[9] = {0xFF, 0x01, 0x79, 0xA0, 0x00, 0x00, 0x00, 0x00, 0xE6}; byte SelfCalOff[9] = {0xFF, 0x01, 0x79, 0x00, 0x00, 0x00, 0x00, 0x00, 0x86}; byte retval[9]; void setup() { pinMode(A7, INPUT); pinMode(A6, OUTPUT); Serial.begin(9600); Serial.print(\u0026#34;400ppm\u0026#34;); Serial.print(\u0026#34;,\u0026#34;); Serial.print(\u0026#34;UART\u0026#34;); Serial.print(\u0026#34;,\u0026#34;); Serial.println(\u0026#34;PWM\u0026#34;); delay(2000); Serial1.begin(9600); Serial1.write(SelfCalOn,sizeof SelfCalOn); } void loop() { //PWMでデータ取得  pwmco2=pulseIn(A7,HIGH,2000000); //UARTでデータ取得  Serial1.write(ReadCO2,sizeof ReadCO2); Serial1.readBytes((char *)retval, sizeof retval); uartco2 = retval[2]*256 + retval[3]; //PCに送信  Serial.print(2*(202000-2000)/1000); Serial.print(\u0026#34;,\u0026#34;); Serial.print(uartco2); Serial.print(\u0026#34;,\u0026#34;); Serial.println(5*(pwmco2-1200)/1000); delay(100); //起動20分後手動キャリブレーション  if(millis()\u0026gt;1200000 \u0026amp;\u0026amp; !reset){ digitalWrite(A6,LOW); delay(8000); digitalWrite(A6,HIGH); reset=true; } }   測定結果 Arduino IDEのシリアルプロッタを使って可視化しました。縦軸がCO2濃度[ppm],横軸が起動からの時間(1が100ms)です。\n  換気したとき\n  人が部屋に入ってきたとき\n横軸1600ぐらいで部屋に入っています。\n  直接息をふきかけたとき\n息をふきかけた直後に値が上昇しました。\n ","description":"","id":10,"section":"blog","tags":["電子工作","Arduino"],"title":"秋月で買えるCO2センサーを使う(MH-Z19C)","uri":"https://771-8bit.com/blog/mh-z19c/"},{"content":"第15回全日本学生室内飛行ロボットコンテストのマルチコプター部門に出場しました。\n飛行ロボコンのマルチコプター部門では、自作したマルチコプターを飛行させ各ミッションを行います。私は高校の航空宇宙同好会として参加し、機体製作を担当しました。このチームでは、カメラで正しい箱を探して物資を投下する「高所物資運搬」、機体重量350gに対し100g程度の物資を運ぶ「大型物資運搬」、決められたコースを飛行する「8の字飛行」の3つのミッションを行いました。\n 機体 予選 決勝  マルチコプター部門には11チームが出場し、予選は3位タイで通過、決勝は4位となりました。大学・高専が中心の大会で普通科高校としては初出場ということもありましたが、あまり良い結果を残せませんでした。会場の通信環境やパイロットからの視点が想定より厳しかったこと、十分な操縦練習時間がとれなかったこと、飛行時間を優先した部品構成にしたため衝突に弱い構造になってしまったことなどが主な原因です。このため予選では8の字飛行に時間がかかり途中でミッションを諦めて帰還し、決勝では大型物資を正しい場所に投下できず、8の字飛行の途中でポールに衝突し棄権という結果になりました。\nそれでも予選ではマニュアル通りの正しい判断で時間内の帰還には成功して決勝に進め、決勝でもメインミッションである高所物資運搬は達成できました。様々反省点はありますが、ロボコンの本番の空気を味わうことができたり、ただものを作るだけではなく本番で運用する難しさが分かったり、良い経験になりました。\n","description":"","id":11,"section":"blog","tags":["ドローン"],"title":"第15回全日本学生室内飛行ロボットコンテスト","uri":"https://771-8bit.com/blog/indoor-flight-15/"}]