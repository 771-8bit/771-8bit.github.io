[{"content":"DashWareというソフトウェアを使い、自作ロガーで取得したデータを動画にオーバーレイ表示する方法をまとめました。\nDashWareとは DashWareは、ロガーで取得したデータを動画にオーバーレイ表示できるソフトウェアです。車・自転車・ドローンなどレースの編集によく使われているようですが、鳥人間コンテストやハイブリッドロケットの動画編集でも便利だと思います。\nネットには既製品のロガーでの使い方はありましたが、自作ロガーへの対応はほぼ手探りで調べたことをまとめたので間違いがあるかもしれません。\nDashWareの使い方 インストール 公式サイトからダウンロードできます。\nプロジェクトの作成 File -\u0026gt; New Projectより、新しいプロジェクトを作成します。Project Templateはデフォルトで表示されるゲージの設定だけなので\u0026lt;None\u0026gt;で問題ありません。\n動画の読み込み 以下のように動画を読み込みます。\nデータの読み込み 同様にデータを読み込みます。\nここからEdit ProfilesをクリックしてData Profileの設定に移ります。\nData Profileの作成 Data Profileを設定することで自作ロガーに対応させます。この記事の本題です。\nここでDashWare Loggerをクローンして自作ロガー用のプロファイルを作成します。名前はMy Loggerにしました。\nCSVのフォーマット 自作ロガーからデータをCSVで吐き出し、Separator Settingで設定した区切り文字、Decimal Formatで設定した小数点にフォーマットを合わせます。\n1行目にはHeader Lineなるものが必須のようで、\u0026ldquo;hello\u0026quot;など適当な文字列を置いておく必要があります。\nCSVファイルは以下のようになります。\n \u0026ldquo;hello\u0026rdquo;\n\u0026ldquo;Time\u0026rdquo;,\u0026ldquo;Elevation Meters\u0026rdquo;\n0,-0.3609\n0.1,-0.3809\n0.2,-0.4609\n0.3,-0.4609\n\u0026hellip;\n データ名の対応 2行目に指定するデータ名は、Column Mappingsで指定します。Column Mappingsの行をダブルクリックし、Data Column Mapping Editorを開きます。\nInput ColumnのInput Data ColumnでCSVファイルに書いたデータ名を指定します。ドロップダウンリストではなくコンボボックスなので好きな文字列を入力できます。ラジオボタンは文字列を含むか完全に一致するかどちらでデータを取り込むかの選択です。CSVファイルでデータ名はダブルクォーテーションをつけることに注意してください。\nColumn Mappingでは、取り込んだデータをDashWare内でなんという名前で扱うかを指定します。カテゴリーとその中の種類を指定するようになっていて、選択肢にないものは選べません。\n時間の設定 時間をもとに動画と同期させるので\u0026quot;Time\u0026quot;は\u0026lt;Required\u0026gt;となっていて必須です。CSVファイルの\u0026quot;Time\u0026quot;の列を時間として読み取ります。単位は秒で正の数しか受け付けません。\nカウントダウンを含む場合など、負の時間を含む場合はこれとは別にデータ列を用意します。\nゲージの設定 Guage ToolBoxから好きなゲージを動画の部分にドラッグアンドドロップして追加します。\nこれをダブルクリックすると詳細な設定が可能ですが、基本的にはColumn Mappingでカテゴリーとデータの種類を適切に設定していれば設定を変更する必要はありません。\n同期 Synchronizationを開いて動画とデータの同期を行います。この操作に関しては公式のチュートリアル動画の0:45以降が分かりやすいです。\n書き出し File -\u0026gt; Create Videoから完成した動画を書き出せます。\n作成例    ハイブリッドロケットの打ち上げの動画をDashWareを使って編集しました。この詳細は別の記事に書きました。\n","description":"","id":0,"section":"blog","tags":["ロケット","鳥人間","電子工作"],"title":"【DashWare】自作ロガーのデータを動画にオーバーレイ","uri":"https://771-8bit.com/blog/dashware/"},{"content":"第20回伊豆大島共同打上実験に参加し、自作ロケットを打ち上げました。\n伊豆大島共同打上実験は、全国の大学生によるハイブリッドロケットの打上実験です。私はCOREのメンバーとして参加しました。COREはハイブリッドロケットの製作・打上げを行う関東圏のインカレです。打ち上げたロケットCANVASは新入生が中心となって製作を行い、私は電装部分を担当しました。\n   打ち上げの様子とロケットのノーズに搭載したカメラの映像、取得したデータをまとめました(DashWareを使用)。\nロケットの詳細は報告書として共同打上実験のHPに公開しています。以下に公開する事柄はこの報告書に全て記述されています。\nこのミッションでは新入生教育を背景として、基礎的なロケットを作ることを目標としました。電装系としては、頂点で開放機構を動作させることとセンサーとカメラのデータを回収することが目標でした。機能としてはシンプルなため一つのマイコンで制御可能ですが、確実に動作する電装を作り、その開発体制をこれから維持できる基盤を作るため、CAN通信を採用したのが今回の電装の特徴です。CAN通信の具体的なメリットは報告書にまとめました。特に、COREはインカレであるためCANでモジュールを分割することにより開発を分担しやすくなりました。CANを使用した以外にも、通信の途絶やモジュールの故障、アップリンクやプログラム書き込みでの操作ミスなど様々なリスクを考慮し、動作テストを繰り返して信頼性を高めました。\n打ち上げ当日は問題なく電装は動作し、パラシュートの開傘とデータの回収に成功しました。取得したデータの詳細は報告書にあります。\n   打ち上げ時の地上局の録画\nハイブリッドロケットの電装は機能としてはシンプルで高度な制御は行っていませんが、本番一回の打ち上げで確実に動作させるという点に難しさと楽しさがあると思っています。打ち上げと全く同じ状況を地上で再現することはできないため、様々なことを考えて設計・製作をする必要があります。打ち上げ時はとても緊張し、パラシュートが開いたときは手が震えるほど嬉しかったです。これからもこの分野でのものづくりを続けていきます。\n","description":"","id":1,"section":"blog","tags":["ロケット"],"title":"第20回伊豆大島共同打上実験","uri":"https://771-8bit.com/blog/izuoshimarocket-20/"},{"content":"pyserialとPySimpleGUIを使ってシリアルモニタを作りました。ArduinoをGUIで操作できます。\n使用したライブラリ pyserial pyserialを使うとPythonでシリアル通信を行えます。これだけでArduinoとの通信は可能ですが、今回はGUIにするためPySimpleGUIも使用しました。\nPySimpleGUI PySimpleGUIはPythonでGUIを扱うためのライブラリで、tkinter・Qt・WxPython・Remiといった既存のライブラリをまとめて簡単にコードを書けるようにしたものです。学習コストをかけずサクッとGUIアプリを作りたい場合は、簡単に書けるPythonとこのライブラリの組み合わせが最適だと思います。\nシリアルモニタ このようなシリアルモニタを自作できます。\nコード全体をのせます。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68  import PySimpleGUI as sg import serial import serial.tools.list_ports import time import threading coms = serial.tools.list_ports.comports() comlist = [] for com in coms: comlist.append(str(com.device)) sg.theme(\u0026#39;DarkBlack\u0026#39;) layout = [[sg.Text(\u0026#39;COMポート\u0026#39;),sg.Combo(comlist, size=(10, 1),key=\u0026#39;selectCOM\u0026#39;, enable_events=True),sg.Text(\u0026#39;\u0026#39;,size=(16, 1),key=\u0026#39;com_state\u0026#39;),sg.InputText(\u0026#39;\u0026#39;, size=(18, 1), key=\u0026#39;uplink\u0026#39;),sg.Button(\u0026#39;送信\u0026#39;, key=\u0026#39;send\u0026#39;)], [sg.Output(size=(97,10))] ] window = sg.Window(\u0026#39;Serial Monitor\u0026#39;, layout,enable_close_attempted_event=True) ser = serial.Serial() ser.baudrate = 115200 ser.timeout = 0.1 def GUIloop(): while True: event, values = window.read() if event == \u0026#34;-WINDOW CLOSE ATTEMPTED-\u0026#34;: if(sg.popup_ok_cancel(\u0026#34;終了しますか？\u0026#34;)==\u0026#39;OK\u0026#39;): ser.close() window.close() break if event == sg.WIN_CLOSED: #ウィンドウのXボタンを押したときの処理 break if event == \u0026#39;selectCOM\u0026#39;: if ser.is_open: ser.close() ser.port = values[\u0026#39;selectCOM\u0026#39;] ser.open() if event == \u0026#39;send\u0026#39;: try: ser.write(values[\u0026#39;uplink\u0026#39;].encode()) window[\u0026#39;uplink\u0026#39;].update(\u0026#39;\u0026#39;) except: print(\u0026#39;err\u0026#39;) def COMloop(): while True: if ser.is_open: window[\u0026#39;com_state\u0026#39;].update(\u0026#39;connected\u0026#39;) try: text=ser.readline().decode(\u0026#39;UTF-8\u0026#39;).rstrip() print(text) except: time.sleep(0.1) else: window[\u0026#39;com_state\u0026#39;].update(\u0026#39;disconnected\u0026#39;) time.sleep(0.1) thread_GUI = threading.Thread(target=GUIloop) thread_COM = threading.Thread(target=COMloop, daemon=True) thread_GUI.start() time.sleep(0.5) thread_COM.start() time.sleep(1)   PySimpleGUI PySimpleGUIについては以下の記事を参考にしました。\n Pythonでも簡単にGUIは作れる  ドロップダウンリストを利用したCOMポートの選択 pyserialの機能で使用可能なCOMポートをlistで受け取れます。この要素を文字列に変換してPySimpleGUIのコンボボックスに追加しています。valuesを通して選択された文字列が受け取れるので、これをもとにCOMポートを開くことができます。\n PySimpleGUIを使ったドロップダウンリストの作成方法について PysimpleGui コンボボックスを動的に変化させる方法  pyserialでの文字列の送受信 文字列ではなくバイナリデータとしてシリアル通信を行うので、送信時は'文字列'.encode()とする必要があります。逆に受信時はser.readline().decode('UTF-8')とします。このプログラムではさらにrstrip()を使いました。\n 【TIPS】Pythonでシリアル通信するpyserialの使い方と動作確認方法[Windows版] Pythonで文字列の前にBをつける  GUI用スレッドとCOMポート用スレッドの処理 GUI用ループとCOMポート用ループを別で走らせるためにデーモンを使用しました。\n Pythonのthreading使ったらプログラムが止まらなかったパターンがある 【Python】スレッドのデーモン化について  応用 これを応用して少し込み入ったGUIも実装できます。これはハイブリッドロケットの地上局のソフトウェアです。この詳細は別の記事に書きました。\n  ","description":"","id":2,"section":"blog","tags":["電子工作","Python"],"title":"pyserialとPySimpleGUIでシリアルモニタ","uri":"https://771-8bit.com/blog/pyserial/"},{"content":"【Lチカの先へ】データシートを読んでセンサーをArduinoで使えるようになる最短ルートとしてelchikaに投稿したものの最新版です。\nはじめに センサーの専用ライブラリに頼らず「データシートを読んでセンサーをArduinoで使える」人が、初心者を同じレベルまで電子工作ができるように教育することを想定しています。Lチカまではたくさん資料があるけど、そこから先はどうすれば…と思って自分のメモとして書きました。そのため、初心者の人がこれを読んで自力で学ぶには不親切かもしれません。目標のセンサーは秋月のセンサーモジュールぐらいのつもりです。\n質の高い書籍や資料は存在しますが、何か一つの資料だけで完璧に習得できるということはまずなく、完璧な入門書を使うとその先が分からなくなるということもあるので、様々な資料を使いながら電子工作に慣れていくというのが良いかなと思います。その主軸として、特に以下のことを考えてこのプランを作りました。\n 本やネットの内容をコピーするのではなく、自分でものを作れること 問題を解決する能力をつけること、問題を回避する能力をつけること 自分でさらに知識をつけることができる基盤を作ること  やること やることを順番にまとめて、学べることを箇条書きにしました。マイコンはSeeduino XIAOを想定しています。\n魚ではなく魚の釣り方を教えるイメージで以下の通りにすれば、電子工作がある程度できるようになると思います。\nチカチカ チカチカ(非安定マルチバイブレータ)を回路図を読んで作ります。できればコンデンサや抵抗を変えて周期の変化を確かめたり、波形をオシロで見せつつ仕組みの解説をしたいところです。\n 回路図の読み方 ブレッドボードの使い方 はんだ付け 電子回路  LEDと保護抵抗 コンデンサ(RC回路) トランジスタのスイッチング    Lチカ まずはLチカでArduinoの基本的な使い方を学びます。プログラミングも初心者の場合はここからゆっくりプログラミングについて教えます。\n Arduino IDEの使い方 デジタル出力  スイッチでLEDのON/OFF スイッチを押したらLEDが光るようにします。\n デジタル入力 プルアップ・プルダウン  PCとシリアル通信 スイッチが押されたらPCにシリアル通信をするプログラムを書きます。printデバッグ用に早めにこれをやると良いかなと思います。押されている間ずっと通信するのではなく押された瞬間に通信するプログラムにします。\n PCとのシリアル通信 スイッチのチャタリング  可変抵抗でLEDの明るさ調整 可変抵抗で分圧回路を作り、それをADCで読み取ってLEDの明るさを調整します。LEDの降下電圧を確認するため、DAC→PWMの順で実践します。PWMの出力波形をオシロで見せられると良いです。\n 分圧 ADC DAC PWM (analogWrite)  Seeeduino XIAOのADC(analogRead)はすべてのピンで10bit、analogWriteは0番ピンのみDACでデフォルトは10bit、それ以外のピンはPWMでデューティー比は8bitで設定できます。詳細はこちらの記事を参照してください。\n圧電ブザー LEDだけだとつまらないので音を出してみます。まずは単純にONOFFを繰り返すプログラムを書いてPWMについて理解したあと、tone関数を使ってみると良いと思います。圧電ブザーはミニゲームでも活用できます。\n PWM  サーボモータ PWMを素直に書いたあと、Servoライブラリを導入すればライブラリについても学べます。\n PWM ライブラリ  スイッチでLEDの点灯/点滅 複数のセンサーや周辺機器を制御することを想定して、あるLEDを一定周期で点滅させつつ、別のLEDのON/OFFをスイッチで切り替えられるようにします。まずはタイマや割り込みを使わないでプログラムを組んで、delay中はスイッチの判定ができないことを確認します。タイマと割り込みについて解説した後、以下のような方法で実装します。\n delayで点滅し、割り込みでスイッチを監視する方法 delayで点滅し、ピン変化割込みでスイッチを監視する方法 タイマ割り込みで点滅し、loopでスイッチを監視する方法 時間関数を使って点滅し、loopでスイッチを監視する方法  Seeeduino XIAOのタイマ割り込みは、Arduino IDEのスケッチ例を参考にしてください。ピン変化割り込みでは、ピンの番号に注意してください。\nこのように割り込みには様々な使い方がありますが、以下の方針で使う方法を選ぶと良いと思います。\n 優先度の高いタスクを割り込みで実行する 割り込みルーチンの実行時間を短くする プログラム全体でdelay関数を使わないでいいようにする  学ぶのは以下の内容です。\n タイマ 割り込み  LEDとスイッチでミニゲーム 数個のLEDとスイッチのセットで作れるミニゲームを実装します。光ったLEDに当たるスイッチを制限時間内に押すモグラ叩きゲームがちょうど良いと思います。これに圧電ブザーを加えてみても良いです。ここでじっくり自力で仕様を考えてプログラムを組んでデバッグすることが重要です。\n 変数や制御文などの\u0026quot;プログラム\u0026quot; デバッグ  部品を壊す 予期しないタイミングで部品を壊してしまうよりは、一度簡単な部品を壊す経験をしてしまう方が安全だと思います。その経験としてLEDを保護抵抗無しで電源(保護回路あり)に直接つなげます。電解コンデンサの逆接は危険ですが、LEDの破壊程度であれば何かカバーを被せれば十分安全に試せると思います。\n 絶対最大定格 故障モード\nLEDの破壊の様子はYouTube等で見ることができます。実験の前に動画を見て危険だと思われる場合は、LEDの破壊の代わりに適切な抵抗を挟んだうえでヒューズを溶断してみるのをおすすめします。   センサ(ADC) いきなりシリアル通信は難しいので、ADCで読めるセンサを使います。\n データシートの読み方  センサ(シリアル通信) シリアル通信(ArduinoのSerial(UART)に限らず)で読めるセンサを使います。Arduinoのコードをなんとなく追うのではなく、まずシリアル通信のプロトコルについてしっかり理解して、どんな信号がやりとりされているのかを把握するべきです。その後Arduinoの関数の役割を理解すれば詰まることなく進められるはずです。\n シリアル通信  使う部品・サンプルコード  必要な知識・スキル 知識そのものを自分で書くと時間が足りないので、いい感じの資料をまとめました。もちろん全部覚えてもらうことはないです。\nほぼ全ての基礎\n電子工作のための電子回路基礎\nArduinoをはじめよう 第3版\n組込みエンジニアの教科書\n実際の製作  はんだ付け\nまずはこれ(村田製作所)\n細かいこと1(HAKKO)\n細かいこと2(GodHanda) ブレッドボードの使い方  プログラミング  C++入門 AtCoder Programming Guide for beginners 苦しんで覚えるC言語  Arduino・マイコン 公式Arduinoリファレンス\ngarretlab\nNOBのArduino日記！\nspiceman\n そもそもコンピュータ・マイコンとは\nDigikey(動画)\nそもそも「マイコン」って何？ マイコンやセンサーを動かすための外部の回路  電源(レギュレータ・コンデンサなど) プルアップ・プルダウン   マイコンの機能  入出力 ADC DAC タイマ PWM 割り込み シリアル通信  UART SPI I2C      一般の回路・部品  Electrical Information\nマイコン以外の電子部品、電気・電子回路 秋月のカタログ\n使える武器が増えるのでどんなカテゴリがあるか知っておいた方が良いです。  単純な技術以外のスキル 問題解決・問題回避 もの作りで一番必要なのは失敗が許容される状況だと思います。無計画でいいというわけではなく、大きな失敗を避けること、失敗してもそれを解決できることが重要です。(チームの場合は人間関係がゴタゴタしないことも重要)\n 問題回避\n最初から完璧を目指して全部作って最後に動作確認をすると、問題の原因特定が困難です。ある程度の機能を作ったら動作テストを心がけ、細かい失敗を前提とした製作をします。Done is better than perfect. 問題解決\n経験があれば問題から直接原因を推測したり、よく観察してすぐに原因を特定できたりしますが、慣れないうちは以下の手順を丁寧に行うことをおすすめします。  分割する\n動かない理由を特定するには、当然ですが動く理由をしっかり理解していることが必要です。そのうえで、仕組みを小さな構成要素に切り分けて一つずつ調べていきます。仕組みの最初から最後まで順番に調べていくのは手間が手間がかかり、どの程度細かく分割すればいいか分からなくなるので、二分探索の要領で進めていくと良いです。 チェックする\n切り分けた各部分について、以下の方法で問題ないか調べていきます。\nA 想定通り動作しているか調べる\nB 条件を変えて調べてみる(対照実験) 分からないことはググる/人に聞く\n質問の仕方     LEDが光らないなら、まずマイコン側と回路側で分割します。テスターを使ってマイコンから正しい電圧が出ていることが分かれば(A)、問題は回路側にあることになります。LEDが故障しているなら、LEDを交換する(B)ことで原因にたどり着くはずです。これは単純な例ですが、複雑な問題も同じように解決できます。\n データシートの読み方 読んで慣れるしかない？\nなにかアドバイスあればコメントください。\n公式ドキュメントの扱い方 公式サイトと他のサイトはそれぞれどちらも長所短所があるので、使い分けを意識します。\n 他のサイトを見て全体像を把握する 公式サイトにたどり着く まずサイトの構成を知る 必要な所を読む   公式ドキュメント(公式リファレンスとも)\nその技術や製品そのものについて書いてある\nそれの仕様,使い方をちゃんと学べる 信頼性が最も高い(外部サイトは情報が古いかも) 他のサイト  それを外部の視点から書いたもの\n他の技術や製品と比べて書いてある 外から見るので全体像が掴める 公式に書いてないことを書いたもの\nバグは外部サイトに書いてある事が多い 公式の記述を要約しているもの\n分かりやすいけど結局公式のトップページが神    おすすめの工具・測定器 おすすめの工具・測定器を布教して終わりにしたいと思います。\n はんだごて FX600 こて台 633-01 こて先 2.4D型 T18-D24 ハンダ吸取器 SS-02   はんだ吸煙器 オシロスコープ HDS272S ","description":"","id":3,"section":"blog","tags":["電子工作","Arduino"],"title":"電子工作入門","uri":"https://771-8bit.com/blog/for-beginners/"},{"content":"「CPUの創りかた」のTD4を製作しました。製作時点で購入できた部品についてまとめてあります。\n作ったもの ロジックICで自作する4bit CPUを「CPUの創りかた」をもとに作りました。集積度が高いのが好きなので、秋月電子のユニバーサル基板のBタイプに収めてあります。実際に作ってデバッグしていくとCPU内のデータの流れがよく理解できました\nデバッグしやすいように動作確認がとれる部分ごとに製作していきました。\n ROMを作って単体で動作確認 クロック回路を作って単体で動作確認 命令デコーダを作ってROMとクロック回路をつなげて動作確認 残りをすべて実装して完成  ROM TD4のオリジナルの回路に加えて、実行中の命令を示すLEDをつけました。ダイオードはカソードコモンのダイオードアレイを使っています。使用したDIPスイッチは幅が狭く実装密度を上げたい場合はおすすめです。\nTD4のROM\n(74HC540買い忘れ) pic.twitter.com/1vrP5s8ATu\n\u0026mdash; 8bitマイコン (@771_8bit) September 19, 2021 普通のDIPパッケージの部品を使うときもハーフピッチ基板を使うとピンの隙間に配線を通せて便利です。\nクロック回路 ICの電源ピンからクリップで電源を供給して動作確認しました。\nTD4のクロック回路(と自作オシロ) pic.twitter.com/CvYocwevLy\n\u0026mdash; 8bitマイコン (@771_8bit) September 20, 2021 命令デコーダ 同じ種類のゲートを入れ替えて配線が簡単になっています。\n動作テスト pic.twitter.com/JgnaEWmPwb\n\u0026mdash; 8bitマイコン (@771_8bit) September 20, 2021 CPU中心部 74HC161はSOPパッケージのものしか入手できなかったのですが、ICの裏に配線を通したかったので変換基板を使って表側に実装しました。レジスタAとレジスタBの値を青色LEDで示せるようになっています。出力レジスタは出力のLEDで、プログラムカウンタはROMの緑色LEDで確認できます。\nTD4完成！ pic.twitter.com/Sthn8hqvNx\n\u0026mdash; 8bitマイコン (@771_8bit) September 23, 2021  主要部品購入先 74HC154は入手できなかったため、こちらの記事を参考に74HC138で置き換えました。3-to-8デコーダを2つ使って4-to-16デコーダを作ります。\n   オリジナル  用途 型番 購入先     74HC74 キャリーフラグ TC74HC74AP (フリッププロップ) 秋月   74HC161 レジスタ・プログラムカウンタ TC74HC161AF (4ビットカウンタ) 秋月   74HC153 データセレクタ TC74HC153AP (4chマルチプレクサ) 秋月 マルツ   74HC32 命令デコーダ TC74HC32AP (OR) 秋月   74HC283 ALU CD74HC283E (加算器) 千石   74HC10 命令デコーダ TC74HC10AP (NAND) 千石   74HC154 アドレスセレクタ TC74HC138AP (3-to-8ラインデコーダ) 秋月   74HC540 アドレス出力 TC74HC540AP (インバータ) 千石   74HC14 クロック回路 TC74HC14AP (シュミットトリガ) 秋月   DIPスイッチ ROM KSD82 (DIPスイッチ 8P) 秋月   ダイオード ROM CE880 (ダイオードアレイ) 秋月    詰まったところ カウンタICの使い方 TD4ではカウンタICのカウントアップ機能を殺してレジスタを作ります。最初はこのあたりをよく理解せずに配線を始めていて、74HC161のENTピンとENPピンをLに落としていませんでした。このため電源を入れるとレジスタAとBが勝手にカウントアップしました。加算回路を調べても正常だったので本を読み直すとICのカウントアップ機能が原因だったことが分かりました。\nプルアップ配線ミス スイッチのプルアップ抵抗を電源側ではなくスイッチ側につけてしまいました。これは実装した翌日に基板を見て気づきました。製作物も製作者も一晩寝かすとデバッグが進みますよね。\nはんだ付け接触不良 レジスタAが常にロードされるような挙動から、レジスタAの74HC161の接触不良に気づきました。\n","description":"","id":4,"section":"blog","tags":["電子工作"],"title":"TD4作ってみた","uri":"https://771-8bit.com/blog/td4/"},{"content":"秋月電子で取り扱いの始まったCO2センサーMH-Z19CをArduino Nano Everyで使ってみました。\nこの記事はQiitaに投稿した記事を再掲したものです。\nMH-Z19Cについて MH-Z19CはNDIR方式のCO2センサで、電源電圧は5.0±0.1V、データの出力はPWMかUART(3.3Vで5.0Vにも対応)です。測定できる範囲はPWMを使うと公称値は400~2000ppm(実測では400~5000ppm)、UARTでは400~5000ppmです(CO2濃度は大気中で約400ppm、室内で約1000ppm、呼気で約30000ppmが目安)。ピンヘッダは2.54mmピッチですが、ピンヘッダとピンヘッダとの間隔が合わずユニバーサル基板に挿すのは難しいので注意してください。\nここでは5V駆動のArduino Nano Everyを使い、PWMとUART両方のデータを読んでみます。\nハードウェア 使ったもの  MH-Z19C Arduino Nano Every 5Ｖ出力昇圧DCDCコンバーターとコンデンサー  Arduinoの5V OUTピンの電圧を測ると4.72-4.78Vでセンサーの電圧の範囲から外れていたので、一応4.9~5.1V出力(実測4.98V)のDCDCコンバーターと100μFのコンデンサーをつけました。\n接続    MH-Z19C      Vin DCDCコンバーター ← Arduino 3.3V   GND Arduino GND   PWM Arduino A7   Hd Arduino A6   Rx Arduino TX1   Tx Arduino RX1    ソフトウェア MH-Z19Cの仕様 データシートはここで読めます。以下の画像はデータシートのものです。\nUART UARTでCO2濃度の読み取りと自動キャリブレーションの設定ができます。\nPWM データシートでは上のようになっていますが、Cppm=5*(パルス幅[ms]-1.2)とするとUARTと同じデータが読み込めました。Arduino Nano EveryのpulseInかセンサーのPWM出力のどちらかが原因だと思います。\n手動キャリブレーションはHdピンを使うのでPWMでもできますが、自動キャリブレーションの設定はPWMだけではできません。デフォルトでは24時間ごとに自動キャリブレーションが行われます。(キャリブレーション時にどんな濃度でもそれを400ppmと認識するのではなく、24時間経ったあたりで400ppmに近い状態と判断するとキャリブレーションを行うようです)\nプログラム 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50  uint16_t uartco2; unsigned long pwmco2; bool reset = false; byte ReadCO2[9] = {0xFF, 0x01, 0x86, 0x00, 0x00, 0x00, 0x00, 0x00, 0x79}; byte SelfCalOn[9] = {0xFF, 0x01, 0x79, 0xA0, 0x00, 0x00, 0x00, 0x00, 0xE6}; byte SelfCalOff[9] = {0xFF, 0x01, 0x79, 0x00, 0x00, 0x00, 0x00, 0x00, 0x86}; byte retval[9]; void setup() { pinMode(A7, INPUT); pinMode(A6, OUTPUT); Serial.begin(9600); Serial.print(\u0026#34;400ppm\u0026#34;); Serial.print(\u0026#34;,\u0026#34;); Serial.print(\u0026#34;UART\u0026#34;); Serial.print(\u0026#34;,\u0026#34;); Serial.println(\u0026#34;PWM\u0026#34;); delay(2000); Serial1.begin(9600); Serial1.write(SelfCalOn,sizeof SelfCalOn); } void loop() { //PWMでデータ取得  pwmco2=pulseIn(A7,HIGH,2000000); //UARTでデータ取得  Serial1.write(ReadCO2,sizeof ReadCO2); Serial1.readBytes((char *)retval, sizeof retval); uartco2 = retval[2]*256 + retval[3]; //PCに送信  Serial.print(2*(202000-2000)/1000); Serial.print(\u0026#34;,\u0026#34;); Serial.print(uartco2); Serial.print(\u0026#34;,\u0026#34;); Serial.println(5*(pwmco2-1200)/1000); delay(100); //起動20分後手動キャリブレーション  if(millis()\u0026gt;1200000 \u0026amp;\u0026amp; !reset){ digitalWrite(A6,LOW); delay(8000); digitalWrite(A6,HIGH); reset=true; } }   測定結果 Arduino IDEのシリアルプロッタを使って可視化しました。縦軸がCO2濃度[ppm],横軸が起動からの時間(1が100ms)です。\n  換気したとき\n  人が部屋に入ってきたとき\n横軸1600ぐらいで部屋に入っています。\n  直接息をふきかけたとき\n息をふきかけた直後に値が上昇しました。\n ","description":"","id":5,"section":"blog","tags":["電子工作","Arduino"],"title":"秋月で買えるCO2センサーを使う(MH-Z19C)","uri":"https://771-8bit.com/blog/mh-z19c/"},{"content":"第15回全日本学生室内飛行ロボットコンテストのマルチコプター部門に出場しました。\n飛行ロボコンのマルチコプター部門では、自作したマルチコプターを飛行させ各ミッションを行います。私は高校の航空宇宙同好会として参加し、機体製作を担当しました。このチームでは、カメラで正しい箱を探して物資を投下する「高所物資運搬」、機体重量350gに対し100g程度の物資を運ぶ「大型物資運搬」、決められたコースを飛行する「8の字飛行」の3つのミッションを行いました。\n 機体 予選 決勝  マルチコプター部門には11チームが出場し、予選は3位タイで通過、決勝は4位となりました。大学・高専が中心の大会で普通科高校としては初出場ということもありましたが、あまり良い結果を残せませんでした。会場の通信環境やパイロットからの視点が想定より厳しかったこと、十分な操縦練習時間がとれなかったこと、飛行時間を優先した部品構成にしたため衝突に弱い構造になってしまったことなどが主な原因です。このため予選では8の字飛行に時間がかかり途中でミッションを諦めて帰還し、決勝では大型物資を正しい場所に投下できず、8の字飛行の途中でポールに衝突し棄権という結果になりました。\nそれでも予選ではマニュアル通りの正しい判断で時間内の帰還には成功して決勝に進め、決勝でもメインミッションである高所物資運搬は達成できました。様々反省点はありますが、ロボコンの本番の空気を味わうことができたり、ただものを作るだけではなく本番で運用する難しさが分かったり、良い経験になりました。\n","description":"","id":6,"section":"blog","tags":["ドローン"],"title":"第15回全日本学生室内飛行ロボットコンテスト","uri":"https://771-8bit.com/blog/indoor-flight-15/"}]