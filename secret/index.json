[{"content":"公式ドキュメントをまとめたつもり\nできること UARTの通信線をTWELITEで無線化する．\n※透過モードに使うためアプリを書き換える必要があります．\nピン接続 VCC・GND・モード設定ビット・UART送受信のピンを接続します．片方のTWELITEのモード設定ビットのM1ピンのみグランドに接続します．他はオープンで良いです．\nhttps://mono-wireless.com/jp/products/TWE-APPS/App_Uart/pinassign.html\nhttps://mono-wireless.com/jp/products/TWE-APPS/App_Twelite/asset/twe_app_pins.png\nTWELITEのTXをマイコンのRXに，TWELITEのRXをマイコンのTXに接続します．UART速度設定ピンは未接続で問題ありません．\nhttps://mono-wireless.com/jp/products/starter/system.html\n設定 TWELITE STAGEのダウンロード  TWELITE STAGEをダウンロードします．\n TWELITEをTWELITE R2に接続してからPCに接続します．\nhttps://mono-wireless.com/jp/products/TWE-LITE-R/r2-dip.png TWELITE STAGEを起動し，シリアルポートを選択します．\n  TWELITE R2との接続について  TWELITE DIPであればTWELITE R2に挿すだけで通信できますが，TWELITE SMDは以下の通りに接続します．\nhttps://twelite.gitbook.io/general/technical-info/progpins  アプリ書き換え  TWELITE STAGEを起動し，「アプリ書き換え」を選択します．\n 「BINから選択」を選択します．\n 「App_Uart_RED」のバイナリを書き込みます．バージョンは異なっても問題ありません．\nhttps://mono-wireless.com/jp/products/TWE-APPS/App_Uart/index.html 書き込みが完了したらEnterでインタラクティブモードに入ります．\n  App_Uart設定  インタラクティブモードに入ります．\n それぞれ設定を行います．設定したい項目の左に書いてあるアルファベット一文字を入力し，指示に従います．設定が終わったらSaveします．\n 通信モードはデフォルトでは独自プロトコルしか受け付けない状態なので，透過モード(D)を選択します． ボーレートはマイコンとTWELITE間のUARTの通信速度であり，無線通信の速度ではないのでここで指定した通りのスループットはもちろん出ません． チャンネルを設定します．番号はIEEE802.15.4準拠で，デフォルトでは18chなので他のTWELITEと干渉する可能性がある場合は注意します．\nhttps://mono-wireless.com/common/images/overview/frequency.svg\n電波干渉回避のため3つまでチャンネルを選択できます．ピンのHLの通信なら問題ないですが，チャンネルを順番に切り替えて送受信するのでデータを取りこぼすことがありUARTには不向きです．\nhttps://mono-wireless.com/jp/products/TWE-APPS/interactive.html   ","description":"","id":0,"section":"blog","tags":null,"title":"TWELITEでUART通信を行う方法","uri":"https://771-8bit.com/blog/twelite-uart/"},{"content":"ステンシルとクリーム半田が無くても一つぐらいならリフローはできる．\n1. はんだを薄ーく盛る 基板側に半田を薄くのせる．平な面のあるコテ先を使うと良い．リフローしないランドにはんだツノを作っておくと焼き上がりが分かりやすい．温度を下げたコテ先に付けて放置した半田を使うとツノが作れる．部品側はフラックスを多めに塗って半田がつきやすい状態にしておく．\n左：もとの基板　右：はんだを薄く盛った基板\n2. ホットプレートをアツアツにする 最大火力にする．焼き上がった時にすぐ回収すればリフロー温度プロファイルなんて関係ない(はず)．\n3. 基板を投入する 基板をつかんでホットプレートに投入する．クッキングシートを忘れずに．\n3. 部品を押し付ける 部品がズレないように注意しながら部品を押し付ける．ホットプレートと基板の熱伝導を良くする目的と，溶けた半田を部品につける目的がある．盛った半田のバラツキで部品がガタつく場合は基板だけ押し付けて半田を溶かした後に部品を押し付けると良い．\n4. 頃合いを見計らって回収する フラックスのいい匂いがしてきたら完成．部品がズレないように注意しながら取る．スルーホールにラジペンを突き刺すと取りやすい．明らかに部品が浮いていたりズレていたりする場合は再度リフローする．\n5. おわり フラックスが揮発しているのでホットプレートをよく洗うこと．\n","description":"ステンシルとクリーム半田が無くても一つぐらいならリフローはできる．","id":1,"section":"blog","tags":["電子工作"],"title":"ステンシルもクリーム半田も無い人の基板クッキング","uri":"https://771-8bit.com/blog/hotplate-soldering/"},{"content":"​星取県宇宙ビジネスプランコンテストで月面におけるワイヤレス給電に関するビジネスアイデアを提案しました。私はプロトタイプの製作を担当しました。\n星取県宇宙ビジネスプランコンテスト 鳥取県は美しい星空や鳥取砂丘での月面実証実験を活用して「星取県」という名前を掲げており、宇宙をテーマにしたビジネスプランコンテストが開催されました。\nhttps://www.space-biz-tottori.com/より\nチーム「Lighthouse」 Lighthouseは、ビジネスサイドの阿部舞哉(あべま)とエンジニアの私がメンバーです。あべまは模擬人工衛星のCanSat開発、私はハイブリッドロケット開発のサークルに所属し、その縁でチームを結成しました。\n月面でのワイヤレス給電 ビジネスプランは「月面にワイヤレス給電を用いたエネルギーインフラを構築する」という内容です。ワイヤレス給電機能を備えたエネルギー給電スタンドを設置し、ローバーや宇宙服などに電力を供給します。鳥取砂丘は月面によく似た環境であり、実証実験の場として最適です。\nワイヤレスのメリット ワイヤレス給電により有線コネクタを排除することは、レゴリス対策・ロボットによる制御の観点からメリットがあります。\n 非常に細かく鋭利で、静電気や磁気を帯びた砂であるレゴリスの影響を受けない。 コネクタ挿抜のために正確な位置制御を行う必要がなく、ロボットに簡単に電力を供給できる。  給電スタンドのメリット ローバーの電力供給として、スタンドからの給電はランダー(着陸船)からの給電と太陽電池による自家発電の間をとったバランスの良い方法です。\n    探査範囲  ローバーの設計      ランダー給電 ❌ ランダー周辺のみ ✅受電のみのシンプルな構成   太陽電池搭載 ✅制限なし ❌ 大きな発電装置が必要   給電スタンド ✅スタンドを点在させ広範囲に ✅ 無線の受電装置のみ    ワイヤレス給電の方式 ワイヤレス給電には様々な方式があります。今回は最も単純な電磁誘導方式から試作しました。\n    効率  伝送距離  特徴      電磁誘導 70%～90% 数mm～数cm Qi規格などで利用   磁界共振 40%～60％ 数cm～数m モビリティ給電で注目   マイクロ波 長距離ほど低下 数m～∞ 長距離送電が可能    https://www.b-plus-kk.jp/wireless_1/wireless_2_1.htmlより\nプロトタイプ製作 今回のコンテストは1/22に「ワイヤレス給電でなんかやろう」という状態でチームを結成し、実際のプロトタイプは3週間で開発しました。\nスケジュール ガントチャートに空白期間があるのは、鳥人間の電装と火星ローバーの電装作ったりスキー行ったりH3の打ち上げ(2/17の方)を見に行ったりしてるからです。ロケットがないだって？ｹﾞﾎｹﾞﾎ\ngantt dateFormat YYYY-MM-DD axisFormat %m-%d todayMarker off section 全体 チーム結成 : milestone, 2023-01-22,1d リサーチ :reserch , 2023-01-23,2023-02-04 プロトタイプ目標設定 : milestone, 2023-02-05,1d 書類提出 : milestone, 2023-02-20,1d 最終審査 : milestone, 2023-02-26,1d section 予定(理想) ラジコン完成 : milestone, 2023-02-17,1d 磁界共振対応 : milestone, 2023-02-26,1d section 製作 1号機製作(モーター回す) : first, 2023-02-06,1d 2号機製作(ラジコン試作) : first, 2023-02-07,2023-02-08 3号機製作(ギヤードモータ) : first, 2023-02-15,1d 4号機製作(2輪化) : first, 2023-02-22,2023-02-23 スタンド製作 : first, 2023-02-20,2023-02-24   (function () { if (window.isMermaidLoaded) return; window.isMermaidLoaded = true; const script = document.createElement('script'); script.src = 'https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js'; script.onload = () = { mermaid.initialize({ startOnLoad: true }); }; document.body.appendChild(script); })();  リサーチ まずは電磁誘導方式や磁界共振方式のワイヤレス給電を試すため、ファンクションジェネレータつきのオシロスコープでコイルとコンデンサを適当につけてちょっとした実験をしてみました。コイルにコンデンサをつけると振幅が大きくなるのは確認できましたが、現状のノウハウから短期間で長距離大電力の伝送を実装するのは難しそうだと判断しました。\nプロービングが雑なのは許して\n試作で挫折しかけてた時にちょうどこのツイートを見て、スーパーキャパシタと工作用のソーラーモーターがあれば小電力のワイヤレス給電でもローバーが作れると気づきました。\nスカイツリーから受信した電力でモーター回してみました https://t.co/CX08x9C5jA pic.twitter.com/mmO2LHuMYT\n\u0026mdash; しんいち💉💉💉💉 (@shinichi_8o2) February 4, 2023  ワイヤレス給電自体は、自作は一旦後回しにしてSeeed製のモジュールを使えることを確認しました。\n目標決定 ビジコンまでは月面で有用なワイヤレス給電技術を開発するのではなく月面でワイヤレス給電が有用であると示せるプロトタイプを制作する\nと割り切って目標を設定しました。\n試作機 1号機 1号機では給電モジュールとスーパーキャパシタで走行できることを確認しました。\n スーパーキャパシタが強力で、15秒の充電で5分程度モーターを駆動できた 3.3vの昇降圧DCDCはトラブルなく動作した ソーラーカーのモーターとタイヤではスピードが早く操縦性に難がある  2号機 2号機ではTWELITEを使って操縦できることを確認しました。\n 片方のタイヤがスリップして走行できない 後転できないと不便だしチップトランジスタじゃなくて素直にモタドラ使ったほうがいい こっちのスーパーキャパシタは公称値に比べて全然電荷が貯まらない  3号機 3号機ではギヤードモータと大きめのタイヤで走行できることを確認しました。↓残ってた写真がこれだけでした。\n ギヤ比1:50のギヤードモーターと50mm径のタイヤを3.3Vで回すとちょうど良い 軽すぎて発進時にウィリーになる タイヤ径が前後で違うとダサい。大きい4輪？クローラー？2輪？  手持ちのクローラーで試したら旋回時の抵抗が大きすぎたので2輪が最適そう(←当たり前)    完成品 ローバー  モータードライバを使用 モーターの固定は取り外しできるように結束バンド スタビライザーも結束バンド スーパーキャパシタは5F5.4V 充電状態を可視化するためにLEDを追加(思ったよりカッコよくなった)  これにカプトンテープを貼って金のシートをかけてそれっぽい見た目にしました。TWELITEのアンテナはシートの中でも問題ありませんでした。\nコントローラ コントローラーはTWELITEのデジタル入力ピンに3ポジションのスイッチをそのまま接続して終わりのシンプルな構成です。\nスタンド 3号機で示した通り中身はなんと牛乳パックです。シートを被せてソーラーパネルをつけるとそれっぽい見た目になりました。小電流でも自動でシャットダウンしないIoT機器対応 モバイルバッテリーを内蔵しています。\n優勝！ あべまの圧倒的プレゼン力により優勝できました。鳥取に行く前に電電宮に行ったり直前までスライドを修正したりした甲斐がありました。（賞金は今回の開発費と旅費でだいたい飛びました…）\nワイヤレス給電を謳いながら今回はワイヤレス給電の開発をしたわけではないので、今後は地に足をつけて電磁気や電波関連を学んでいきたいです。\n","description":"​星取県宇宙ビジネスプランコンテストで月面におけるワイヤレス給電に関するビジネスアイデアを提案しました。私はプロトタイプの製作を担当しました。","id":2,"section":"blog","tags":null,"title":"宇宙ビジコンでサッとプロトタイプを作って優勝してきた","uri":"https://771-8bit.com/blog/space-biz-tottori/"},{"content":"Windows PCの環境構築備忘録\n初回起動時  ローカルアカウントで作成  user下のフォルダ名を好きにいじるため   マイクロソフトアカウントへのログインに切り替え  ソフトウェアアップデート  Windows Update メーカーのプリインストールソフトでドライバ・BIOSアップデート  不要なソフトのアンインストール  サードパーティ製ウイルス対策ソフト(Windows Defenderを有効化) その他プリインストールソフト  設定変更  ディスプレイの拡大縮小を100%に 拡張子・隠しファイルを表示 スリープ無効化 パネルオープンパワーオン無効化 電源ボタン・高速スタートアップの解除 ダークモード・アクセントカラーはブルーグレー アクティブ時間を15:00~9:00に(夜間の自動再起動防止) タスクバー項目の設定 おすすめ非表示  ソフトのインストール マイナー(偏見)なものはリンクつき\nインストーラーのインストーラー ここは順番通りにインストールすると楽\n Chrome  uBlock Originは必須   google日本語入力 7-zip Windows 11 Classic Context Menu マウスとか周辺機器のソフト AutoHotKey  基本ソフト  Google Drive Mery EarTrumpet Vivaldi FireFox Office TeX Live Adobe Acrobat Reduce PDF Size CubePDFpage gnuplot MATLAB Mathematica  連絡ツール  LINE Slack Discord Zoom Skype  開発系 一般  VScode Visual Studio Git GCC Python DevToys PowerToys  組込  Arduino IDE Teraterm PortPop SD card formatter Etcher VNC ラズピコ  ハード  Fusion360 KiCad Quadcept LTspice OpenRocket  画像  Paint.NET GIMP draw.io Inkscape XnView  動画  OBS Studio VLC youtube-dl LosslessCut DaVinci Resolve  システム  everything WizTree CrystalDisk Info Mark CoreTemp HWmonitor CPUID ","description":"","id":3,"section":"blog","tags":null,"title":"PC環境構築","uri":"https://771-8bit.com/blog/pc-settings/"},{"content":"CapsLock+WASDを↑←↓→にする方法\n概要 頻繁に使用する矢印キーは右の小指で押しづらい位置にあるのに、最も要らないCapsLockキーはとても押しやすい位置にあります。そしてCapsLockの隣には移動でおなじみのWASDキーがあります。CapsLock+WASDを↑←↓→にするのは必然です。必ず設定しましょう。\n Change KeyでCapsLockキーをF13キーと認識させる AutoHotkeyでF13+WASDを↑←↓→にする  Change Key 後述するAutoHotkeyではCapsLockを認識できないことがあるので、別のソフトを使ってF13として認識させます。\n 窓の杜からインストールします。 Change Keyを起動し、CapsLockキーを選択します。\n 右上のscan codeをクリックします。\n F13のスキャンコードである0064を入力します。\n 「登録」してから「終了」します。\n  AutoHotkey  公式サイトからインストールします。 任意のディレクトリに、以下の内容の\u0026quot;hoge.ahk\u0026quot;というファイルを作成します。 1 2 3 4  sc0064 \u0026amp; w::Send, {Up} sc0064 \u0026amp; a::Send, {Left} sc0064 \u0026amp; s::Send, {Down} sc0064 \u0026amp; d::Send, {Right}    作成した\u0026quot;hoge.ahk\u0026quot;をダブルクリックして起動し、正常に動作していることを確認します。 \u0026ldquo;hoge.ahk\u0026quot;のショートカットを作成し、こちらのサイトの通りにスタートアップに登録します。\n ","description":"","id":4,"section":"blog","tags":null,"title":"WASDを↑←↓→にしよう！","uri":"https://771-8bit.com/blog/wasd2arrow/"},{"content":"今はリンクを知っている人だけ見れます．\n開発用資料+引継資料+公開用資料\nはじめに 鳥人間コンテスト滑空機部門の電装の開発についてまとめます．\n設計の根拠がわかるように，要求定義から記録に残しました．\n2022年のEclatはまずラダーが動けばヨシ！で開発したので2023年は本気で\nDone is better than perfect, but next is perfect. * 開発の参考資料 * [システムズエンジニアリングの基本的な考え方 初版（JAXA）](https://ssl.tksc.jaxa.jp/isasse01/kanren/BDB/BDB06007BSEkihon.pdf) ## 開発手法について SySML * [SysMLの要求図の書き方](https://forza.cocolog-nifty.com/blog/2013/08/sysml-619c.html) * monoist * [モデリング言語 SysMLを概観する](https://monoist.itmedia.co.jp/mn/articles/0909/28/news081.html) * [ブロック定義図の基礎](https://monoist.itmedia.co.jp/mn/articles/1002/08/news094.html) * [UMLやSysMLなどのモデリングは“いつ”“何を”“どうするのか”](https://monoist.itmedia.co.jp/mn/articles/1511/02/news001.html) * システムエンジニアリングでSysMLを使いこなす * [第1章　概要編－システムエンジニアリングとしての SysML](https://www.ogis-ri.co.jp/otc/hiroba/technical/SysEngSysML/SysEngSysML1.html) * [第2章　実践編－電光掲示板を設計する(1)](https://www.ogis-ri.co.jp/otc/hiroba/technical/SysEngSysML/SysEngSysML2.html) * [第2章　実践編－電光掲示板を設計する(2)](https://www.ogis-ri.co.jp/otc/hiroba/technical/SysEngSysML/SysEngSysML3.html) * [要求を整理してみよう ](https://astah.change-vision.com/ja/tutorial/files/requirements.pdf) -- 設計 要求定義  システムの要求  パイロットの操作でラダーを制御する プラットホーム上で姿勢を確認する パイロットに対地高度を伝達する フライトデータを取得する   電装班運営の要求  必要な技術を継承する    要求分析 共通事項  フライトまでバッテリーが持つ 着水時に発煙・発火しない フェールソフト  システムの要求の優先度が低いものの故障が高いものに影響を与えないこと コクピフレームとの接触による短絡，通信線の切断などを想定 特に想定すること  操舵系のみの電源供給が選択可能であること SDに問題が起きても他の機能は維持すること     メンテナンス性  プラットフォーム上でメイン電装の電源を起動できる メイン電装部を機体から取り外した状態で，機体に取り付けた各電装部と電気的に接続して動作テストができる 琵琶湖でメイン電装のプログラムを変更できる   耐候性  機体が直射日光にあたり温度が上昇しても動作する 多少の水滴では故障せず動作し続ける (直射日光下で)LEDを見る必要なく運用できる   電気的制約  SPIは通信速度が速く，I2Cはプルアップが不安定なため基板内のみで使用 基板間の通信はUARTおよびそれに近い規格(RS422など) マイコンの動作電圧は多くのセンサーに合わせて基本3.3V   技術(力)的制約  Arduinoを使用し，自力でライブラリを書かなくて良い構成とする CANはなるべく使用せず，UARTによる文字列送受信を行う チップ部品は使用しない ケーブルの圧着はせず，既製品を使用する    操舵  パイロットの操作でラダーを制御する  入力を読む  ゼロ点を認識する 任意のカーブを設定できる   ラダーを動かす  十分なトルクがある  風   信号・電力の減衰が起きない  ケーブルが断線しない ケーブルの電圧降下が小さい       その他の要件  トラブル時ニュートラルでフライトできる 琵琶湖でニュートラル調整が可能である テールを軽くする (機体内通信含む)無線で操舵を行ってはならない(大会ルール)    姿勢モニタ  プラホからの発進時に姿勢などを確認できるようにする  以下のデータをダウンリンクする  ロール・ピッチ 対気速度   受信機はポケットに入る程度のサイズにする  PC・タブレットは大きくてプラットホームで扱いづらい(特に雨天時)      高度計  パイロットに対地高度を伝達する  対地高度を推定する  測定精度は0.1m単位を要求 技術的な制約  高高度では気圧高度を，低高度では超音波高度を信用すべき  気圧高度は湖面からの絶対高度は分からない 超音波は高高度からでは届かない   気圧センサ  動圧・ハッチの衝撃によるセンサーの外れ値を弾く 中央値を取るために違う場所に3つの気圧センサを配置する   超音波センサ  水面付近は気圧高度より信用できる       パイロットに情報を伝達する  モニター，表示機以外で伝達する  テープLED 聴覚 \u0026lt;- 触覚       その他の要件\n*  ロギング  下記のデータを記録する     優先度 測定値 要求     高 GPS ある程度信頼できるため冗長の必要はない   高 超音波高度 超音波が干渉するため一つだけ搭載する   高 気圧高度 高度計の信頼性を確保できる分だけ搭載する   中 ラダー操作量 どの故障モードでもラダー操作に影響を与えない   中 9軸・姿勢 複数搭載なら異種のセンサーを搭載する   中 対気速度 機体外に搭載する必要がある   低 AoA 機体外に搭載する必要がある   低 AoS 機体外に搭載する必要がある     データを同期した状態で記録する 着水時にデータをロストしない  requirementDiagram requirement test_req { id: 1 text: \"パイロットの操作でラダーを制御する\" risk: high verifymethod: demonstration } functionalRequirement req_input { id: 1.3 text: \"入力を読む\" risk: medium verifymethod: demonstration } interfaceRequirement input_feedback { id: 1.5 text: \"入力値をパイロットが認識できる\" risk: medium verifymethod: demonstration } interfaceRequirement input_zero { id: 1.5 text: \"ゼロ点を認識する\" risk: medium verifymethod: demonstration } interfaceRequirement input_curve { id: 1.6 text: \"任意のカーブを設定できる\" risk: medium verifymethod: demonstration } functionalRequirement req_servo { id: 1.2 text: \"ラダーを動かす\" risk: medium verifymethod: demonstration } physicalRequirement req_wire { id: 1.2 text: \"信号・電力の減衰が起きない\" risk: medium verifymethod: demonstration } physicalRequirement req_break { id: 1.2 text: \"ケーブルが断線しない\" risk: medium verifymethod: demonstration } physicalRequirement req_voltage_drop { id: 1.2 text: \"ケーブルの電圧降下が小さい\" risk: medium verifymethod: demonstration } physicalRequirement req_voltage_drop { id: 1.2 text: \"サーボの電流が増える\" risk: medium verifymethod: demonstration } physicalRequirement req_wind { id: 1.2 text: \"風による外力を受けても動作する\" risk: medium verifymethod: demonstration } performanceRequirement req_battery { id: 1.9 text: \"フライトまでバッテリーが持つ\" risk: medium verifymethod: demonstration } designConstraint req_weight { id: 1 text: \"テールを軽くする\" risk: high verifymethod: demonstration } designConstraint weight_cable { id: 1 text: \"ケーブルを軽くする\" risk: high verifymethod: demonstration } physicalRequirement req_failsafe { id: 1.2 text: \"トラブル時ニュートラルでフライトできる\" risk: medium verifymethod: demonstration } test_req - contains - req_input req_input - contains - input_zero req_input - contains - input_curve req_input - contains - input_feedback test_req - contains - req_servo req_servo - satisfies - req_wire req_servo - satisfies - req_wind test_req - derives - req_battery req_input req_failsafe req_servo  (function () { if (window.isMermaidLoaded) return; window.isMermaidLoaded = true; const script = document.createElement('script'); script.src = 'https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js'; script.onload = () = { mermaid.initialize({ startOnLoad: true }); }; document.body.appendChild(script); })();  requirementDiagram requirement test_req { id: 1 text: \"対地高度の伝達\" risk: high verifymethod: test } functionalRequirement test_req2 { id: 1.1 text: the second test text. risk: low verifymethod: inspection } performanceRequirement test_req3 { id: 1.2 text: the third test text. risk: medium verifymethod: demonstration } interfaceRequirement test_req4 { id: 1.2.1 text: the fourth test text. risk: medium verifymethod: analysis } physicalRequirement test_req5 { id: 1.2.2 text: the fifth test text. risk: medium verifymethod: analysis } designConstraint test_req6 { id: 1.2.3 text: the sixth test text. risk: medium verifymethod: analysis } element test_entity { type: simulation } element test_entity2 { type: word doc docRef: reqs/test_entity } element test_entity3 { type: \"test suite\" docRef: github.com/all_the_tests } test_entity - satisfies - test_req2 test_req - traces - test_req2 test_req - contains - test_req3 test_req3 - contains - test_req4 test_req4 - derives - test_req5 test_req5 - refines - test_req6 test_entity3 - verifies - test_req5 test_req  (function () { if (window.isMermaidLoaded) return; window.isMermaidLoaded = true; const script = document.createElement('script'); script.src = 'https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js'; script.onload = () = { mermaid.initialize({ startOnLoad: true }); }; document.body.appendChild(script); })();  -- 基本設計  要求から設計への落とし込みの根拠  癖のある設計はしてないつもりなので，特記事項のみ↓ メインマイコンはDue一択  マイコンの駆動電圧は3.3V(センサーの制約) UARTがたくさんほしい 有名なArduinoボードでこれらを満たすのはDueのみ   ジョイスティック電装部と機体下電装部は統合しない  操舵系はクリティカルなため余計な機能を混ぜない   姿勢取得のためにカメラを搭載  センサーデータを使うよりカメラ映像の方が確実   電源設計  駆動系は火災防止のためサーボに過電流保護を挟んで供給，VHコネクタのため逆接保護は無し それぞれのマイコンは独立した過電流保護を挟んで供給   姿勢モニタの受信側のデバイスはスマホのシリアルモニタ  液晶・7segを使うのは技術的にダルい スマホアプリの開発は面倒だけど、シリアルモニタなら楽      全体像 物理的な配置  メイン電装部には電装ハッチを用意 ジョイスティック電装部はパイロットが操作しやすい位置に 機体下電装部は超音波センサを湖面に垂直に向けることができれば場所は任意 スピーカー部は場所は任意(音が聞こえるならメイン電装部に統合も可) エアデータ電装部はコクピ上  設計陣との調整で翼から生やすことになった 三面図提出時点は左翼に配置で確定 重量バランスはダミーウェイトで調整する (同じものを2つ作るのは非常に難易度が高い)    質量概算    コンポーネント 寸法[mm] 質量[g] memo     メイン電装部 100×150×70 300~600 Lipoが60g，Dueが60g，防水をちゃんとやると+300g   カメラ 81x65x78 200 防水ハウジング含む   カメラ 48x50x53 85 本体が防水   エアデータ電装部 あざみ野ぐらい 40 ピトー管含めた電装部品のみの質量，AoA・AoS無し   機体下部電装部 50mm四方の基板一枚 20 ロケットのノーズが20g   ジョイスティック電装部 50mm四方の基板一枚+ジョイスティック 30 ジョイスティックのサイズに依存   ラダー部 43×32×33 60 サーボモータのみ   スピーカー部 直径50ぐらい 50 音量を求めると重くなるかも    詳細設計 予算    コンポーネント 予算     メインマイコン周辺(スピーカー含む) 0,000   操舵系(ジョイスティック電装部・ラダー部) 0,000   機体下部電装部 0,000   エアデータ電装部 0,000   カメラ 30,2853,800   基板発注代 10,000    カメラは完全に班長の趣味なので，空力・構造的な問題がなく予算のみが問題であれば私費投入？\nUARTフォーマット 桁が固定されていない小数をカンマ区切りで送信し，改行コードLF(\\n)をつける．ボーレートは115200bpsとする．\n気圧[hPa],温度[deg],気圧高度[m],超音波高度[m]\n気圧[hPa],温度[deg],気圧高度[m],差圧[Pa],対気速度[m/ss],AoA[rad],AoS[rad]\nコネクタ・ケーブル  すべて手で圧着はせず、コネクタ付きのケーブルと半田スリーブを使用  半田スリーブ(白)  AWG26-24用らしいけど22までは使える     コネクタ  汎用：JST-XHコネクタ  2,3,4,5ピンの在庫がある PAコネクタのほうが抜き挿ししやすいけど入手性が悪い 半田スリーブを使うと2.0mmピッチは狭い、XHは2.5mmピッチ XHアッセンブリワイヤー   中継：JST-SMコネクタ  中継用ならこれ？ TORICA-UARTの中継  SMケーブル  シールドふくめて5Pを使用 ピトー管用だとHR30も良さそうだけどケーブル側がない     サーボの中継  SMケーブル  シールドふくめて4Pを使用 最大電流3Aで，他のいい感じの中継コネクタもないからこれで       サーボの差し込み部分のコネクタ  サーボ専用の端子は使わない サーボに付属する専用のコネクタを切って半田スリーブで接続する   4P TORICA-UART  1 黒 GND 2 赤 5V 3 緑 Due TX - XIAO RX DTXR 4 白 Due RX - XIAO TX DRXT × 青 シールド   5P ICS-UART  1 黒 GND 2 赤 5V 3 緑 ICS TX - XIAO RX ITXR 4 白 ICS RX - XIAO TX IRXT 5 青 EN   4P JOYSTICK  1 黒 GND 2 赤 3.3V 3 緑 X 4 白 Y   4P サーボ  黒 GND 赤 LiPo VCC 白 ICS 青 シールド     ケーブル  サーボ・電源用ケーブル  FA用300V電源・低速移動屈曲配線ケーブルシールド有 3芯・シールドあり・AWG22(QIコネクタ,2550コネクタの最大)・3m以上   その他信号用ケーブル  シールド付きスリムロボットケーブル ↑とモノタロウでまとめて買ってもいいけど千石でも売ってる      電源部  サーボの過電流保護  リセッタブルヒューズを挟む  【ポリスイッチとは】ヒューズとの違いは？ トリップ電流(遮断しうる最小電流)：6.0A \u0026gt; サーボの最大消費電流 遮断電流(瞬時に遮断する電流)：40A 保持電流(遮断後に流れ続ける電流)：3.0A 温度上昇でディレーティングしても(保持1.56A/トリップ3.12A@85℃)なのでセーフ   サーボの最大消費電流は3.1A   電源スイッチ  サーボ無しでも200mA程度消費するので、なんらかの電源スイッチは必要 サーボに最大負荷がかかったときのことを考え、12V5A定常的に流せる回路を作る 半導体スイッチを使うフライトピンは電気的に複雑になるので使わない(参考ツイート) 電源スイッチはレバーロック式のトグルスイッチを使う   電源BOX  電源部は防水のためロック付きのタッパーを使う  透明なのは必須   搭載するバッテリーはKypom K6 11.1V 2200mAh 35C70C  Eclatと同じ   以下のケーブルをケーブルグランドを使って出す（どちらも同じ電流が流れる）  メイン電装に供給する電源ケーブル 電源スイッチにつなぐケーブル   ケーブルグランドPG7  選定は適合ケーブル径だけ見れば基本OK  防水等級はIPX7で良い。IPX8はいらん   これの取付穴径(ドリルで開ける穴)は12.7mm ケーブルグランドつけてもコネクタのせいで結局取り外しはできないので、シーリング材で固定しても良い 今回は鳥科に在庫あって見た目もいいから採用 ケーブルの長さの調整ができるのがややメリット？\n       マイコンへの電源供給  それぞれにM78AR05-0.5を使用 過電流保護を搭載(入力側にスパイクがないことを確認済み・自動復帰あり) 電源に近い部分に過電流保護を持たせるため，DCDCはメイン基板に搭載し5Vをケーブルで配電する   コンデンサ配置  Arduino Dueの回路図参考 VINに47uFついてる． DCDCで5Vに落とす．VIN側に10uF，5.5V側に47uFついてる． 5Vからレギュレータで3.3Vに落とす．3.3V側に10uFついてる． GPSとスピーカーの消費電流が大きいので，5Vラインにコンデンサを外付けする． XIAOが載った基板にはコンデンサを外付けする．    メイン電装部(メインマイコン)  I2Cセンサーについて  I2C接続のセンサーとの通信は一連の送受信が高速に行われるためプリエンプションを認めない． プリエンプションを認めないため，タイマ割り込みで処理を行う． ISRの起動周期はデータレートと同じ100Hzとする． I2Cの速度はBNO055の最大の400kHzとする(DPS310はMHzクラス)．   UARTについて  UART接続のセンサー・マイコンはバッファにデータが貯まるため，プリエンプション(中断)されることを認める． 時間のかかるSDアクセスに割り込むため，タイマ割り込みで処理を行う． I2Cセンサーの処理へのプリエンプションを認めないため，優先度を一つ低くする． GPSは10Hz，他のマイコンは100Hzでデータを送信するが，すぐにデータを処理するためISRは500Hzで起動させる． GPSは受信だけ，TWELITEは送信だけのため，1つのUARTポートで処理を行える．\n   SDについて  SDカードへのアクセスは時間がかかるため，SPIをSDカード専用バスとする． SDカードへのアクセスはプリエンプションを認める． 優先度が低いためメインループで処理を行う．   音声合成ICについて  音声合成ICとの通信はプリエンプションしても問題ないが，プリエンプションを認めないI2Cセンサーと独立させるためにI2C1に接続する． I2Cの速度はICの最大の400kHzとする． 通信で厳密なリアルタイム性を求めないことは音声合成ICのタイミングチャートで確認した． 優先度が低いためメインループで処理を行う．        タスク名 起動周期 優先度 中断 概要     ISR_I2C0_100Hz 100Hz 14 禁止 メインマイコンに直接接続されたGPSを除いたセンサーのデータ取得   ISR_UART_500Hz 500Hz 15 許可 ジョイスティック電装部・機体下部電装部・エアデータ電装部・GPSからのデータ受信   flash_SD 1Hz loop() 許可 SDカードへの書き込み   callout_altitude 0.5Hz loop() 許可 高度の読み上げ    調べた限り気圧センサはDPS310が一番高精度\nDPS310精度やばすぎて草\nこれが静電容量式気圧センサの力か… pic.twitter.com/TUkWzHqA4O\n\u0026mdash; だん (@kogakudanshi) June 19, 2022    アンプつきスピーカー候補(可変抵抗による音量調整機能付き)  Adafruit(あざみ野2022) Seeed Studio    メイン電装部(操舵系)   ジョイスティック候補\n Adafruit 秋月 千石  セイミツ工業のものはアナログジョイスティックではなくマイクロスイッチでON/OFFが分かるだけなので注意      可変抵抗を用いてニュートラル調整\n 抵抗値は10kΩ    サーボのあいてるコネクタにコンデンサを配置\n     部品 個数 価格     KRS-4034HV ICS 2(予備含む) 17,600   ICS変換基板 1 1980   Seeeduino XIAO 1 850   小型アナログジョイスティック 1 528   ジョイスティック基板 1 319   可変抵抗 1 50    機体下部電装部 ハードウェア  超音波センサとは 部品候補  10Hz以上で測定できる UART(RS232・TTLシリアル)以外で通信できる       部品 個数 価格     Seeeduino XIAO 1 850   超音波センサー URM37 V4.0 1 1,870   DPS310 1 1,408    ソフトウェア  メインループで行う処理  SDカードへの書き込み  書き込みに時間がかかるのでメインループ   超音波高度の取得  測定に時間がかかるのでメインループ SDカードの書き込みより早く測定できることはないのでメインループでOK     割り込みで行う処理(XIAOは割り込み一つ)  メイン電装へのUART送信  UARTフォーマットにのっとって，気圧・温度・気圧高度・超音波高度を送信する センサーの測定レートはバラバラだがUART送信は100Hzで行う．それぞれのセンサーについて測定できたタイミングで値をグローバル変数に書き込み，ISR内で100Hzで送信する．   メイン電装からのUART受信  文字列を受信し，そのままmicro SDに書き込む． 文字列をバッファに入れるだけで，SDへの書き込み自体はメインループで行う．   気圧センサのデータ取得  メインループで行うと測定レートが遅くなるので割り込み内で行う． 100Hzで最新の値を取れるわけではないので，最新値が取得できたときだけグローバル変数に書き込む．         関数名 起動タイミング 概要     loop() メインループ 超音波高度の取得・SDカードへの書き込み   ISR_100Hz() 割り込み100Hz メイン電装へのUART送受信・気圧センサのデータ取得    エアデータ電装部 ハードウェア AoA・AoSは希望者がいなかったのでまずはピトー管のみで製作をすすめる．差圧センサはSensirionのSDPを使用する．公式でArduinoライブラリが用意されていて使いやすい．\n差圧センサーはHoneywellのRSCかSensirionのSDPがとてもよい．これ使ってからピトー管係数が1から大きく外れたことがない．微差圧計測は温度補正の効くセンサーに限る\n\u0026mdash; へーりん (@pakfat50) June 1, 2022     製品 方式 振動 ドリフト チューブでの圧損     Honeywell RSC ダイヤフラム 影響あり あり 影響なし   Sensirion SDP 流量 影響なし なし 影響あり      方式と設計方針\n ピトー管からチューブを伸ばして翼の安定した部分にダイヤフラム式のセンサを配置する ピトー管のそばに流量式のセンサを配置する    今回は流量式のセンサを使用する\n ドリフトの調整を省略できる チューブの圧損は設計で確定するが，フライト時の振動は想定しづらい．    SDPの中のSDP810-500PAを採用\n ノイズに弱いアナログではなくI2C通信 最大~m/s=500Paのレンジ 簡単に手半田可能なパッケージ SDP811はI2Cアドレスが違うだけ    CFRPのパイプに全部いれる\n 強度はいらないけど軽いパイプがほしい センサは削れば内径30mmに入る マイコン・気圧センサも30mmに入る もともと内径30mmだったけど外径30mmに変更       部品 個数 価格     Seeeduino XIAO 1 850   SDP810-500PA 1 5,261 (Eclat流用)   ピトー管 1 1,397   DPS310 1 1,408   CFRPパイプ 1 4,264    ソフトウェア  メインループで行う処理  SDカードへの書き込み  書き込みに時間がかかるのでメインループ     割り込みで行う処理(XIAOは割り込み一つ)  メイン電装へのUART送信  UARTフォーマットにのっとって，気圧・温度・気圧高度・超音波高度を送信する センサーの測定レートはバラバラだがUART送信は100Hzで行う．それぞれのセンサーについて測定できたタイミングで値をグローバル変数に書き込み，ISR内で100Hzで送信する．   メイン電装からのUART受信  文字列を受信し，そのままmicro SDに書き込む． 文字列をバッファに入れるだけで，SDへの書き込み自体はメインループで行う．   気圧センサのデータ取得  メインループで行うと測定レートが遅くなるので割り込み内で行う． 100Hzで最新の値を取れるわけではないので，最新値が取得できたときだけグローバル変数に書き込む．   差圧センサのデータ取得  メインループで行うと測定レートが遅くなるので割り込み内で行う． 100Hzでグローバル変数に書き込む．         関数名 起動タイミング 概要     loop() メインループ SDカードへの書き込み   ISR_100Hz() 割り込み100Hz メイン電装へのUART送受信・気圧センサのデータ取得・差圧センサのデータ取得    カメラ    部品 個数 価格     SP360 4K 1 20,565   防水ケース 1 9,720   JOY700(楽天で中古入手) 1 3,800     メリット  姿勢，翼のたわみ具合，垂直尾翼の角度などのデータが確実に取得できる   デメリット  ちょっと高い(本体は藤田の私物で防水ケースだけ鳥の予算にしようかな) ツルツルのカウルに突起ができる    配置の詳細  ToDo 画像貼る  メイン電装部  緑のところのコクピフレームに固定する  他だとダメな理由  着水時にPに当たる可能性があって危ない(発泡に埋め込むのはメンテだるい) (パイプの隙間に配置)Pの腕とかで邪魔そう 重心調整で桁を動かすから邪魔 足で蹴られそう ハッチの邪魔 ハッチの邪魔     固定は桁ではなくフレーム側  他の電装がフレームにつくから サーボは胴体桁ではなくテール桁なので桁に電装があるメリットなし 詳細な固定方法は電装の実物ができてから   胴体桁の左右にバッテリー，メイン電装，GPSモジュールを分けて配置する カウル上側に電装ハッチを用意する 搭載スペース  左右160mm×上下方向60mm×前後300mm が左右で2つある 電装本体はこれより小さい(バッテリーGPS除いて60×30×120)    サーボのケーブル  胴体桁部分は桁の外側を通す 桁の外側でコネクタを繋ぎ，テール桁に接続する  コネクタは脱着のため外に出てると良い   テール桁の側面に穴を開け，ケーブルを埋め込む  サーボがテール桁に埋め込まれるからケーブルも    ジョイスティック電装部  ジョイスティックに近いフレームに結束バンドで固定  スピーカー  TBD  機体下電装  黄色の部分に配置する  後方だと蹴られる 高度取得のため機体の一番下に取り付けたいので桁や翼には配置したくない   フレームではなくカウルに基板を固定する  カウルに超音波センサ用の穴を開けてを埋め込みたい フレームにセンサを取り付けるとカウルの取付精度に制約が生じる 重量は100g無い程度なので問題ないはず   カウルに中継ケーブルを這わせておき，カウルをフレームに取り付けたあと，青部分でフレームのケーブルと接続する  カウルをフレームに取り付けてから基板を取り付けるのは，パイロットが乗る板やハッチと干渉するため困難 テグスもここまで這わせてフレームに縛り付ければロスト対策もOK    エアデータ電装部  BC間のフランジに固定する 基板を全てCFRPの内径30mmのチューブ内にまとめ、チューブの底面からケーブルを出す チューブをフランジに固定する  カメラ  主翼桁の前の養生の発泡の上に埋め込む  胴体桁軸上に配置したい フライト直前にアクセスできる位置に  読売からNOGOが出ればダミーロードを載せられるように カメラはケーブル繋がないので埋め込んでOK      スケジュール gantt dateFormat YYYY-MM-DD axisFormat %m todayMarker on excludes weekends %% (`excludes` accepts specific dates in YYYY-MM-DD format, days of the week (\"sunday\") or \"weekends\", but not the word \"weekdays\".) section システム設計 ミッション要求定義 :req_def , 2022-10-17,2022-10-27 システム要求分析 :req_analysis , after req_def , 7d 基本設計 :Functional_design , after req_analysis , 7d 詳細設計 :physical_design , after Functional_design , 2022-11-29 section 電装班外と調整 基板搭載場所仮決定 : milestone, 2022-11-20,1d 基板搭載場所確定(ピトー管以外) : milestone, 2023-02-02,1d ピトー管場所確定 : milestone, 2023-02-17,1d ピトー管固定方法確定 :milestone , 2023-03-21,1d コクピ内電装固定 :kotei , 2023-04-28,2023-05-10 section 電装全体 BBM統合 :milestone , 2023-02-21,1d 基板設計 : pcb, 2023-02-03,2023-03-01 FM基板実装 :milestone , 2023-03-06,1d ケーブル製作 : cable, 2023-05-10,2023-05-12 section メインマイコン 構成部品候補の調査 :research , 2022-10-17,2022-11-01 音声合成ICハードウェア :callout_integrate , 2022-12-01 , 2022-12-15 内蔵センサー値取得 :sense ,2023-01-10 , 2023-01-17 SD記録 :sd , 2023-01-17 , 2023-01-24 スケジューリング :sche , 2023-01-24 , 2023-01-31 操舵量取得 :ctrl , 2023-01-31 ,2023-02-06 SD高速化 :sd_fast ,2023-03-06 ,2023-03-09 合成音声仕様決定 :callout_spec , 2023-04-07 , 2023-04-14 音声合成ICコマンド解析 :callout , 2023-04-14 , 2023-04-31 音声合成関連データ処理 :alt , 2023-05-11 , 14d section 操舵系 ICSサーボ引き継ぎ :ICS , 2022-12-02 , 1d BBM完成 :milestone , 2022-12-09 ジョイスティック選定 :stick , 2023-01-31 , 2023-02-06 section 電源部 電気的仕様決定 :power , 2023-04-07 , 2023-04-14 外装設計・製作 :case , 2023-04-14 , 2023-04-28 section 機体下電装部 超音波センサ選定 :sonic , 2022-11-29 , 2022-12-02 BBM完成 :milestone , 2022-12-15 プログラム : pitot,2023-04-28,2023-05-11 section エアデータ電装部 取付治具製作 : pitot,2023-03-20,2023-05-12 プログラム : pitot,2023-04-14,2023-04-28 section カメラ カメラ選定 :camera , 2023-02-04 , 1d プログラミング :OpenCV , 2023-05-18 , 2023-06-31 section テスト 水没試験 :water , 2023-02-22 , 1d End-to-End試験 :e2e , 2023-06-02 , 1d ロングラン試験 :longrun , 2023-06-09 , 1d 温度環境試験 :sunlight , 2023-07-07 , 1d section テレメトリ 仕様決定 :tele_need , 2023-03-09 , 2023-03-11 乗り込み練用送受信機製作 :air_hard , after tele_need , 2023-03-16 無線ハブ基板設計 :radio_design , 2023-04-07 , 2023-04-14 無線ハブ基板実装 :radio_impl , 2023-04-21 , 2023-04-28 プログラム :radio_program , 2023-04-14 , 2023-05-11 section リブ切り台電源 TBD :kyouiku , 2023-04-06 , 2023-05-30 section 新入生教育 練習用基板設計 :kyouiku , 2023-04-14 , 2023-04-21 練習用基板製作 :radio_impl , 2023-04-21 , 2023-05-12 section 鳥科全体 桁試験 : milestone, 2022-12-27,1d 新歓 : milestone, 2023-04-06,1d 初全組 : milestone, 2023-06-04,1d 初TF : milestone, 2023-06-11,1d 鳥コン : milestone, 2023-07-29,1d section 班長の都合 ロケット打上げ :rocket_voilet, 2022-11-11,2022-11-13 中間試験 :mid, 2022-11-08,2022-11-16 ロケット繁忙期 :rocket_happa , 2022-12-30,2023-01-27 期末試験 :last , 2023-01-17,2023-01-25 インターン繁忙期 :AE , 2023-03-20,2023-04-05   (function () { if (window.isMermaidLoaded) return; window.isMermaidLoaded = true; const script = document.createElement('script'); script.src = 'https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js'; script.onload = () = { mermaid.initialize({ startOnLoad: true }); }; document.body.appendChild(script); })();   BBM : ブレッドボードモデル，試作\n FM :フライトモデル，本番用  製作 電装基礎知識  これ ついったー  ソフトウェアの管理  GitHub  organization コンポーネントごとにリポジトリを作る(ブランチ説明したくないしconflictさせたくない) どうせ引き継ぎはどこかで失敗するので23代だけのorganizationにした． 同じ理由でリポジトリはすべてPublic． GitHubの使い方  公式ドキュメント 動画 Conventional Commits      基板設計  基板設計はKiCadを使う．  KiCad ことはじめ  全体像はこれの10ページが分かりやすい   KiCad 6.0 動画解説  基本的に動画解説の流れにそって進めればOK     ソフトウェアと同じGitHubで管理する．  リポジトリは分ける．   Tips  参考：パッド寸法 Arduinoシールド  Arduino Dueは外形が同じなのでMegaのシールド(マイコンボードの拡張基板)のテンプレートが使える   XIAO KiCadライブラリ シンボル自作方法 フットプリント自作方法 基板外形 自動配線ツール  KiCadのPCBエディタでパターンを引くのは機械任せにできる   JLCPCB発注方法    基板実装  はんだ付けに関しては↓を見ればOK\n   部品を両面に実装する場合などは部品を取り付ける順番に要注意 防塵  金属・CFRPのカケラが基板に落ちて短絡するなどを防ぐ必要がある 樹脂によるポッティングは不可逆なので避けたい カプトンテープをペタペタ貼って保護する    コンポーネントごとの製作 電源部 メイン電装部(メインマイコン) graph LR classDef done fill:#ffa23e データをSDに記録データをSDに記録] 高度読み上げ高度読み上げ] タスクのスケジューリング確定タスクのスケジューリング確定] データを取得--データをSDに記録 SDへの書き込み:::done-------データをSDに記録 UARTの文字列をパースして数値を取得:::done UARTの文字列をパースして数値を取得--エアデータのデータ取得 UARTの文字列をパースして数値を取得--機体下のデータ取得 9軸センサのデータ取得:::done---メイン電装部のセンサーデータ取得:::done GPSのデータ取得:::done---メイン電装部のセンサーデータ取得 メイン気圧高度取得:::done--メイン電装部のセンサーデータ取得 メイン気圧高度取得--気圧高度の中央値の取得 メイン電装部のセンサーデータ取得--データを取得 機体下のデータ取得--データを取得 エアデータのデータ取得--データを取得 操舵量取得---データを取得 対地高度の推定--データを取得 エアデータのデータ取得--エアデータ気圧高度取得 機体下のデータ取得--機体下気圧高度取得 機体下のデータ取得--超音波高度の取得 エアデータ気圧高度取得--気圧高度の中央値の取得 機体下気圧高度取得--気圧高度の中央値の取得 気圧高度の中央値の取得--対地高度の推定 超音波高度の取得--対地高度の推定 対地高度の推定---高度読み上げ 音声合成ICとの通信:::done--音声合成 スピーカのアンプ回路--音声合成 音声合成--高度読み上げ タイマ割り込み:::done--タスクのスケジューリング確定:::done UARTの文字列をパースして数値を取得--タスクのスケジューリング確定 SDへの書き込み--タスクのスケジューリング確定 click SDへの書き込み \"/secret/birdman-glider-avionics/#SDへの書き込み\" _blank click UARTの文字列をパースして数値を取得 \"/secret/birdman-glider-avionics/#UART\" _blank click タイマ割り込み \"/secret/birdman-glider-avionics/#タイマ割り込み\" _blank click 9軸センサのデータ取得 \"/secret/birdman-glider-avionics/#BNO055\" _blank click メイン気圧高度取得 \"/secret/birdman-glider-avionics/#BME280\" _blank click GPSのデータ取得 \"/secret/birdman-glider-avionics/#GT-902PMGG\" _blank click 音声合成ICとの通信 \"/secret/birdman-glider-avionics/#ATP3012F6-PU\" _blank   (function () { if (window.isMermaidLoaded) return; window.isMermaidLoaded = true; const script = document.createElement('script'); script.src = 'https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js'; script.onload = () = { mermaid.initialize({ startOnLoad: true }); }; document.body.appendChild(script); })();  Arduino Due  Arduino Due 1 Arduino Due 2  \nSDへの書き込み  ピン配置  フォーマットは以下の通り\n TYPE,経過時間[ms],値,値,… GPS,経過時間[ms],hh,mm,ss.f,緯度[udeg],経度[udeg],アンテナ海抜高度[m] PRESSURE,経過時間[ms],気圧[hPa],温度[deg],気圧高度[m] IMU,経過時間[ms],X[m/ss],Y[m/ss],Z[m/ss],qW,qX,qY,qZ RUDDER,経過時間[ms],角度 UNDER,経過時間[ms],気圧[hPa],温度[deg],気圧高度[m],超音波高度[m] AIR,経過時間[ms],気圧[hPa],温度[deg],気圧高度[m],差圧[Pa],対気速度[m/ss],AoA[rad],AoS[rad]  \nUART SerialUSB (Native USB Port only)に注意\n 公式リファレンス XIAO ピン配置 UART区切り  UART区切り1 UART区切り2   UART抽象化  \nタイマ割り込み タイマ割り込みにはDueTimerを使用した上で優先度を設定する．優先度は0(最高)～15(最低)で表される．\n TC1ブロックに含まれるTimer3をISR_I2C0_100Hzに,Timer4をISR_UART_500Hzに割り当てる．   DUEでは標準ではTC1のブロックは使用していないらしい 参照\n  SysTick(delay()やmillis()に利用)の優先度(デフォルト15)の優先度をタイマ割り込みより高くする．~~  SysTickいじると書き込みが不安定になったので割り込み内での時間関数は諦める．   ISR_I2C0_100Hz()のTimer3の優先度を，ISR_UART_500Hz()のTimer4の優先度より高くする． UARTの処理をISR_UART_500Hz()で行うため，Timer3の優先度をUART受信割り込み(優先度不明)より低くする．つまり最低にする． 優先度はNVIC_SetPriority()により設定する．TC3_IRQnはTC3のことではなく，Timer3のことである．参照  1 2 3 4 5  Timer3.attachInterrupt(ISR_I2C0_100Hz).start(10000); Timer4.attachInterrupt(ISR_UART_500Hz).start(2000); //NVIC_SetPriority((IRQn_Type)SysTick_IRQn, 13); NVIC_SetPriority((IRQn_Type)TC3_IRQn, 14); NVIC_SetPriority((IRQn_Type)TC4_IRQn, 15);    DueTimer 割り込みの優先度詳解 データシート該当部  \nBME280  秋月商品ページ Arduinoライブラリ  DPS310  Arduinoライブラリ データシート  データレートとオーバーサンプリングの設定は以下の通り ここらへんを参考に 気圧と温度のデータレートは同じがいいらしい 温度は気圧に比べればそこまでの精度はいらない  1 2  dps.configurePressure(DPS310_32HZ, DPS310_16SAMPLES); dps.configureTemperature(DPS310_32HZ, DPS310_2SAMPLES);    気圧計算  \nBNO055  秋月商品ページ チップデータシート Arduinoライブラリ  \nGT-902PMGG   秋月商品ページ\n  u-center\n 通信速度を115200bpsに データレートを10Hzに 時刻緯度経度高度が含まれるセンテンス(GGA)のみ出力    コンフィグ保持\n  GPSのQ\u0026amp;A\n  u-center\n  NMEAセンテンス選択\n  Arduinoライブラリ\n  \nATP3012F6-PU(音声合成)  秋月商品ページ I2C関連  I2C概要 ArduinoでI2C I2C高速化    メイン電装部(操舵系) サーボモータ KRS-4034HV ICSを使用する．「市販のマイコンボード，小型PCボードから制御する」を参考に\n ハードウェア  ICS基板の接続   ソフトウェア  Arduinoライブラリ ライブラリの使い方    ジョイスティック 機体下部電装部 外形  C基板サイズ  超音波 気圧 XIAO micro SD    URM37 V4.0  サンプルコード  エアデータ電装部 テスト 共通事項  フライトまでバッテリーが持つ\nロングラン試験 着水時に発煙・発火しない\nサーボモータ部分を短絡させ，発熱発火しないこと，短絡復帰後に動作することを確認する． フェールソフト\n機体下部電装部のコネクタを引き抜いたうえで短絡させ，ログと操舵が動作し続けることを確認する．\nエアデータ電装部のコネクタを引き抜いたうえで短絡させ，ログと操舵が動作し続けることを確認する．\n操舵系のみの電源供給ができることを確認する．\nSDを引き抜いても操舵が動作し続けることを確認する． メンテナンス性\nTBD 耐候性\n各コンポーネントを接続し，50℃以上30分以上の動作を確認する．リポバッテリーは防爆バックに，他は黒い紙で覆って直射日光に曝す．\nBBM，EMで水没試験を行う．\n短絡故障はしないことが確認できた．波形はかなり歪む． 電気的制約\n機体に取り付けた状態で，波形を確認する．  操舵  基本\n操縦桿を動かし，ラダーを動かせる．\n手でトルクをかけ，ラダーが動作することを確認する． その他の要件\n可変抵抗を操作し，ニュートラルの位置を変更できる．\n操舵系のみの電源供給，操舵系以外のみの電源供給の両方が選択可能である．  テレメトリ  TBD  高度計  TBD  ロギング  下記のデータをタイムスタンプつきで記録できることを確認する．\nTBD 着水時にデータをロストしない\nSDを抜いてデータがロストしないことを確認する．この試験はTBD回行う．  完成したシステム 概要 コンポーネント詳細 UARTのプルアップを忘れたので各基板にUARTのRXにプルアップ抵抗を違法建築した．\nメイン基板  ソフトウェア 基板\n  無線ハブ基板  基板\n  テレメトリ受信機  ドキュメント  ジョイスティック電装部  ソフトウェア 基板\n  機体下部電装部  ソフトウェア 基板\n  エアデータ電装部  ソフトウェア 基板\n  運用 組み立て トラブルシュート メイン電装の書き込み Arduino DueはProgramming PortとNative Portの2つのUSBポートが存在する．マイコンがハングアップしているとNative Portからは書き込みができないが，Programming PortはSerial(ジョイスティック電装部に接続)と共通のポートを使用しているため，書き込み時はSerialには接続しないでおく必要がある．\nあらかじめProgramming PortとNative Portの両方にUSBケーブルを接続しておき，必要であれば琵琶湖でもUSBケーブルを延長してPCから書き込みを行う．通常時はNative Portから書き込みを行い，問題が起きたときはジョイスティック電装部を外してProgramming Portから書き込みを行う．\n ","description":"","id":5,"section":"secret","tags":null,"title":"鳥コン滑空機の電装の開発","uri":"https://771-8bit.com/secret/birdman-glider-avionics/"},{"content":"セキュリティ・キャンプ2022のX3【ハードウェア魔改造ゼミ】の参加記です。ルーターにArduinoをつなげてスマホから操作できるラジコンを作りました。\nX3 ハードウェア魔改造ゼミ 概要 Wi-FiルーターにArduinoをつなげてスマホやパソコンから操作できるラジコンを作りました。セキュリティキャンプの中でも異色のゼミですが、分野を問わず存在する攻撃から守るために幅広い分野について知るべきで、電気回路からHTTPまで全レイヤーを触ってみようという趣旨になっています。\n この講義は電波法への抵触リスクに慎重に配慮して実施されていると講師から案内がありました。また、講義内でも電波法について学んだ上で制作しました。 ハードウェア構成 黒枠内のラジコンにWi-Fiルーターを搭載し、スマホ・パソコンなどのクライアントからHTTPでルーターのサーバーと通信して操作します。モーターはルーターにUSBケーブルで繋いだArduinoからモータードライバ経由で回します。\n GL.iNet GL-MT300N-V2  このルーターにはオープンソースのOpenWrtが初めからインストールされていて、Raspberry Piのようなシングルボードコンピュータとして扱えます。無線通信に関するコードを直接書き換えることはしないので、Raspberry Piのプログラミングと同じように電波法には抵触しません。   Arduino Nano Every TB6612使用 Dual DCモータードライブキット ツインモーターギヤーボックス  Arduinoからモーターを回す ArduinoはUARTで以下の情報を受け取ります。\n 左右のモーターの回転方向（ブレーキ・ニュートラル・時計回り・反時計回り） 左右のモーターの回転速度\n  これをモータードライバに伝えてモーターを回します。\n モータードライバのHブリッジ回路で回転方向を切り替え ONとOFFを高速に切り替え(PWM)、平均電力をコントロールして速度調整\n  今回は電源がモバイルバッテリーの5V系一つしかないため、モーターの大電流による電圧降下からArduino・ルーターを守る必要がありました。\n 回路にコンデンサを追加して瞬間的な電流をカバー PWMのON/OFF比(Duty比)の最大値を低くする PWM周期を短くして電源電圧の振動を軽減 Duty比をゆっくり目標値に近づける 過負荷で電源電圧が落ちたらDuty比を半分にする  以下のオシロスコープの波形は黄色がPWM信号、青色がラジコン全体の電源電圧です。\n\nサーバーの実装 ArduinoをUSBケーブルでルーターに繋ぎ、MicroPythonからモーターの状態をUARTで操作します。このMicroPythonの上にnanowebというフレームワークでWebサーバーを実装します。\n以下の機能を実装しました。\n 矢印・STOP ボタンによる前後左右の動作 レンジスライダーによる左右のモーターの直接操作 ポーリングにより状態を同期し、複数クライアントでの同時操作に対応  ラジコンのフェイルセーフ HTTPでやりとりするリソースであるJSONのデコードに失敗するバグが発生しました。時間内に根本原因は特定できませんでしたが、try-exceptで対処しました。他にもバグがある可能性に備えて、フェイルセーフとして異常終了時にはモーターを停止するようにプログラムを変更しました。\n1 2 3 4 5  try: loop.run_forever() //メインループ開始 finally: s.write(\u0026#39;0,0,0,0;\u0026#39;) //Arduinoにモーター停止を伝える s.close() //シリアルポートを閉じる   コントローラーのフロントエンド実装 JavaScriptはサーバーとの通信に関わるのでそれなりに理解する必要がありましたが、HTMLやCSSは雰囲気で書きました。よくわからんが、まぁ動いてるからヨシ！\n日記 日記という名のメモ\n8/8(1日目)  開講式・LT会・共通講義・グループワークのみで開発ゼミの時間はなし  8/9(2日目) 電気回路  STBYピンを基板内部でプルアップ モーターの極性は揃えた 電流食い過ぎ\u0026amp;電圧ヤバすぎ問題に気づく  とりあえずたくさんコンデンサをつける  470uFと100uFを外付け 基板内に10uFの積セラあり   分圧してADCにつっこむ回路を組む  基準電圧が電源電圧だと意味がないので1.1V基準にするため12kと3kで分圧 INTERNALじゃだめでINTERNAL1V1でやった      マイコン開発  電圧降下対策でPWMの周期を早めた  Hの時間が長かったらその間ずっと降下する 手順  ググって出てきたブログで叩くべきレジスタを特定 データシートを読んで内容を理解、レジスタを書き換える TCAを書き換えたためPWMと一緒にdelayも爆速になってしまうことを確認。一度はdelay_msをdelay*64で用意して乗り切ろうとした ググってQiitaでタイマの割当を知り、使うタイマとPWMピンを変更。それに合わせてレジスタを叩く     ロケットのテレメトリのコードを移植してカンマ区切りでデータを渡せるようにした (爆アド)  ルーターセットアップ  家のWi-Fiが見つからない！  家のルーターの設定で2.4GHzのアクセスポイントを無効にしていたのを思い出し2.4GHzに切り替え  電子レンジでよく切れた      ルーターとマイコンを結合  minicomの設定いじいじ  ハードウェアフローコントロールの解除(必須なのかは不明)  Arduino→minicomはできたけど逆ができなくて、その対処としてやった   minicom→Arduino  minicomは改行コードなしでキーを押した瞬間に送信(TeraTermと同じ) 改行コードを使ってコマンドをパースしてたので改行コードの有無に関係なくカンマとセミコロンでパースできるように変更。(これもロケットのコードから移植)   改行コード  CR+LFで送ると二行改行しちゃう CRで送ると改行するだけでカーソルが戻らないのでminicomでCRを有効化     HTTPを学ぶ curlからHTTP通信ができることを確認 pythonからUART叩いてモーター回すとこまでやった  8/10(3日目) サーバーサイドをサンプルコードで動かす  まずはREST APIはいじりたくなかったのでUARTの通信内容を書き換えて動作確認 curlで動作確認  フロントエンドもサンプルコードで動かす  まずはサンプルコードでボタンの動作確認 その後スライドバーでスロットルを直接動かす機能を実装  電源とかPWMとか  モーターをぶん回したらルーターの電源が落ちた  ちゃんと（？）制御をやってみる   ルーターの電源回路を観察  809RLと書かれた部品を発見  データーシート 電源電圧を監視してリセットをかける部品 下限電圧は2.63Vで意外と余裕があることが判明   レギュレーターのドロップアウト電圧を知りたかった  電源回路にインダクタがあったのでDCDCを組んでそう スイッチング用っぽい素子の詳細は不明   MCU自体の下限は2.97V  データシート   5Vから結構攻めて良さそうだったのでとりあえず3.3V+マージンで3.5Vを下限にした    CSSとの格闘  最低限はできたのでCSSと格闘  bootstrap何もわからん 全部vmで設定    複数端末の対応  ここらへんでREST APIをようやく理解 定期的にGETしてデータをもらう形式で実装 定期実行でアロー関数が使えないらしく、普通の関数に書き換え  理由は知らない 参考？   JSONのデコードに失敗してサーバーが落ちる不具合が発生  try-exceptで回避 プログラム終了時にシリアルを閉じる直前にモーター停止のフェイルセーフ    8/11(4日目) モーターが片方しか回らないバグの対処  オーバーロードしたら両方同時に出力を切るように変更  原因じゃなかった ずっと出力がおかしいから一時的な制御の問題じゃなくて通信の問題   ISR内部でのシリアル通信をやめた  通信を見ると明らかにUARTでの送信ができてなかった ISRでフラグ書き換え、メインループでフラグ監視方式 Serialが衝突しないから通信エラーがなくなった    GETの頻度を1Hzから2Hzに  ちゃんと動いた  発表資料の作成  Marpはいいぞ  8/12(5日目)  いろいろ発表  開発コース以外のイベント LT会 参加者交流としてLT会が設けられています。講師・チューターの方と、受講者の希望者が発表します。1日目のLTを見て自分も発表したくなり、さらにその日のグループワークのテーマ決めでCPU自作の話題が出たので4日目に4bit CPU自作について発表できました。ブログをMarkdownで書いておくとMarpで簡単にスライドにできるのでおすすめです。\nグループワーク セキュリティ・キャンプ終了後も、受講生同士で集まって好きなことができるようにグループワークが用意されています。自分のグループではRustの勉強会をすることになりました。他のチームではメンバーの興味がバラバラなため、さまざまな分野が協力できるCTFや分野指定なしのブログリレーなどをするところが多かった印象ですが、このチームでは全員Rustに興味があったのでRustを選択できました。\n完走した感想  とにかく楽しい  サンプルコードはあったけど2,3日で集中して作るのが楽しい discordでいろいろ話すのが楽しい   安定したハードを作るのが大事  ハードが信頼できないと上のレイヤーに上がれない（今回は電源）   基本情報/応用情報の勉強が役に立った  ネットワークとかHTTPとか、広く浅く知るのには良かった   手を動かす、大事  サンプルコードを参考に手を動かして独自の機能を実装するうちにHTTP通信を理解できた   勉強したいことが増えた  UARTとHTTPをMicroPythonで簡単に繋げられたので、中間の組み込みLinuxをやってみたい  終わったけどスタート感はある#seccamp\n\u0026mdash; 8bitマイコン (@771_8bit) August 12, 2022   ","description":"","id":6,"section":"blog","tags":["セキュリティ・キャンプ"],"title":"セキュリティ・キャンプ2022 X3 参加記","uri":"https://771-8bit.com/blog/seccamp-x3/"},{"content":"BME280の詳細なチューニングと設定ごとの精度や応答速度についてまとめました。BMP280でもほぼ同じように設定できます。\n環境 マイコンはArduino互換のSeeeduino XIAO、センサーは秋月電子のAE-BME280、ライブラリはAdafruitのものです。ボードのメーカーやライブラリが異なっても設定項目は同じです。\n設定項目 ライブラリに丸投げすればread()などの関数で値を読むことはできますが、用途ごとに精度や消費電力を最適化する場合やライブラリを自作する場合に必要な設定について簡単にまとめました。主にデータシートの3. Functional descriptionの内容です。\n測定モード BME280には2つの測定モード(3.3 Sensor modes)があります。\nForced Mode Forced Modeでは、マイコンからの命令により1サイクルだけ測定をしてマイコンに送信します。\nNormal Mode Normal Modeでは、常に測定を繰り返して値をセンサー内(出力レジスタ)に保存し、マイコンからの命令により最新の値を送信します。測定を繰り返す頻度は測定そのものにかかる時間($t_{measure}$)と待機時間($t_{standby}$)によって決まり、$t_{standby}$を明示的に指定します。\n測定の流れ BME280にオーバーサンプリングと内蔵IIRフィルタの機能があるため、\u0026ldquo;1サイクル\u0026quot;の測定が複雑になっています。センサーの出力レジスタの値が書き換わるのが\u0026quot;1サイクル\u0026quot;です。まずそれぞれ機能の説明をしたあと、測定の流れについてまとめ直します。\nオーバーサンプリング 1サイクルで温度・気圧・湿度をそれぞれ複数回測定して出力値を安定させることができます。測定回数はそれぞれ独立に設定でき、測定を省略することも可能です。\nIIRフィルタ オーバーサンプリングが1サイクル内で複数測定するのに対し、IIRフィルタは前のサイクルまでの値を使って出力値を安定させます。IIRフィルタは$filter_{coefficient}$という定数で設定します。この定数を用いて、前回の出力レジスタの値$data_{filtered-old}$と最新のセンサーの生の測定値$data_{ADC}$の加重平均を計算して新しい出力レジスタの値$data_{filtered}$とします。なお、$data_{ADC}$はオーバーサンプリング後の値です。\n$$ data_{filtered}=\\frac{data_{filtered-old}\\cdot (filter_{coefficient}-1)+data_{ADC}}{filter_{coefficient}} $$\n$filter_{coefficient}$は1,2,4,8,16が設定でき、1にすると式から明らかなようにIIRフィルタが無効になります。\n1サイクルの値をそのまま出力するわけではないのでノイズが減りますが、複数サイクルの値を使うので応答速度が下がります。この遅れはデータシートのFigure 7: Step response at different IIR filter settingsを参照してください。\n全体の流れと測定時間 Figure 6: BME280 measurement cycleの通りです。\n 測定開始 気温測定(オーバーサンプリング含む) 気圧測定(オーバーサンプリング含む) 湿度測定(オーバーサンプリング含む) 出力レジスタ更新(IIRフィルタ含む) 測定終了  測定時間$t_{measure}$はオーバーサンプリングをどの程度するかによって決まり、9.1 Measurement timeの通り計算できます。\nAdafruitライブラリでの設定方法 Adafruit_BME280.hのsetSamplingを用いることで設定を変更できます。引数の定数は同じファイルに列挙型で定義されています。\n221 222 223 224 225 226  void setSampling(sensor_mode mode = MODE_NORMAL, sensor_sampling tempSampling = SAMPLING_X16, sensor_sampling pressSampling = SAMPLING_X16, sensor_sampling humSampling = SAMPLING_X16, sensor_filter filter = FILTER_OFF, standby_duration duration = STANDBY_MS_0_5);   チューニング 編集中\n3.5 Recommended modes of operation\n","description":"","id":7,"section":"blog","tags":["電子工作"],"title":"BME280の詳細設定","uri":"https://771-8bit.com/blog/bme280/"},{"content":"セキュリティ・キャンプ2022のX3【ハードウェア魔改造ゼミ】に通過したので応募課題の回答を公開します。\n応募したコース 「電気回路からHTTPに至るまで全レイヤーに触れる」というところが楽しそうだったので、X3を第一希望にしました。X1とX4も課題の内容が被っていたため応募しておきました。\n X3【ハードウェア魔改造ゼミ】 X1【リバースエンジニアリングゼミ】 X4【無線通信ハッキングゼミ】  課題 セキュリティ・キャンプ全国大会2022 オンライン 開発コース X3【ハードウェア魔改造ゼミ】応募課題\n (1)以下の技術用語について解説してください。またどのようなところで使われているかも述べてください。わからない場合は調べて、自分なりに解釈した結果を述べてください。\n「オームの法則」「UART」「SPI(Serial Peripheral Interface)」\n(2)マイコンのファームウェアをデバッグするためには、どういう方法がありますか？\n(3)電気には直流と交流があります。同じ電圧のとき、どちらが感電したときに危険だと思いますか？その理由と一緒に説明して下さい。また感電はどんな工夫をすれば防げるでしょうか、思いつく限り多く挙げてください。\n(4)このデータシートから、以下の情報を読み取ってください。\nデータシートURL：\nhttps://datasheets.raspberrypi.com/rp2040/rp2040-datasheet.pdf\nrp2040-product-brief.pdf (raspberrypi.com)\n・GPIOに5.0Vを入力しようと思います。この機器は正常に動作しますか？\n・この機器でSPI通信は使用できますか？\n・IOVDDとDVDDの違いを説明してください\n・SWDポートを使うと何ができますか？\n・GPIO 1ポートから標準で何mA出力できますか？またGPIO合計で最大何mAまでの電流を出力できますか？(ただしQSPIポートで使用する電流は考慮しないものとします)\n(5)以下の質問に答えてください。\n・電波を発射する装置を日本国内で合法的に使用するには、「電波法で定められた基準に適合しているという証明」が得られた無線機が必要です。この証明の名前はなんですか？\n・市販されている無線ルーターの多くには、機能を完全に置き換えられる純正ではないファームウェアが存在します。非純正のファームウェアがインストールされた状態でWi-Fiを有効化すると、上記の証明が無効になり違法となる可能性があります。何を原因としてその可能性が生じるのか考察してください（簡潔な記述を望みます・400文字以内）。\n 回答 ※内容の正確性は保証できません\n(1)技術用語の解説 オームの法則 オームの法則は、回路に流れる電流Iが電圧Vに比例するという法則であり、V=RIと表されます。この比例定数Rを電気抵抗といいます。これは電磁気学の範囲では導出できない経験則で、導出する場合には物性物理の範囲に踏み込む必要があります。また、オームの法則に従わない非線形素子も存在し、半導体はまさに非線形素子です。\nオームの法則なしに電気回路について考えることはできません。単純な例として、LEDの保護抵抗を計算するためにもオームの法則は必要です。定格の電流を流すため、電源電圧からLEDの電圧降下を引いた電位差を定格電流で割ることにより保護抵抗を求めます。この抵抗を直列にLEDに接続することでLEDに定格電流を流すことができます。\nUART UARTはUniversal Asynchronous Receiver/Transmitterの略で、2つのデバイスの間でシリアル通信を行うプロトコルです。\nシリアル通信は、複数の信号線を用いてデータをまとめて送受信するパラレル通信に対して、データを1bitずつ順に送受信する通信方式です。組み込み用途で使われるシリアル通信としては、UART・SPI・I2Cが有名です。\nシリアル通信には、1対多で通信できるものもありますが、UARTは1対1の通信で、マスター(親機)・スレーブ(子機)の区別はありません。\nUARTでは基本的には送信用のTXと受信用のRXという信号線のみで通信します。片方機器のTXをもう片方の機器のRXに繋いでデータを送ることができます。基本的には互いにTXとRXを接続する全二重通信を行いますが、一方向通信で良いときは片方のTXと片方のRXだけを接続した単向通信も可能です。また、フロー制御を行うためCTSやRTSといった信号線を接続することもありますが、あまり一般的ではありません。\nUARTのAはAsynchronousの頭文字で、クロックを使用しない非同期式という意味です。予め決めた速度でTXからビット列を送信し、その速度でRXから読み出してデータをやりとりします。クロック線に同期して信号をやりとりするものは、USART(Universal Synchronous Asynchronous Receiver/Transmitter)といいます。\nUARTはデータはパケットに分割して送受信されます。パケットはスタートビット・データビット・パリティビット・ストップビットで構成されます。通信の開始と停止を示すのがスタートビットとストップビットです。データビットが実際に通信したい内容であり、5～9ビットが使用できますが7～8ビットが一般的です。パリティビットは通信内容に誤りがないか確認するためのビットです。データビットの長さ・パリティビットの詳細・ストップビットの長さは、通信速度とともに使用する機器同士で共有しておく必要があります。\nUARTは1対多ではなく1対1の通信となるため、マイコン間での通信や、マイコンとパソコンとの通信・マイコンと通信モジュールとの通信に用いられることが多いです。通信が高速なSPIや電気的にやや不安定なI2Cが同じ基板内のデバイス同士での通信に使用されるのに対し、UARTは異なる機器同士での通信も可能であり、差動伝送に変換すればより長距離での通信が可能となります。\nSPI(Serial Peripheral Interface) SPIはSerial Peripheral Interfaceの略で、1対多でシリアル通信を行うプロトコルです。\n一つのマスター(親機)がバス全体を制御します。チップセレクト(CS)・スレーブセレクト(SS)などと呼ばれる線を用いて通信相手となる子機を選択して通信します。デイジーチェーン接続も規格上可能ではありますが、あまり一般的ではありません。\n信号線には、マスター出力/スレーブ入力のMOSI・マスター入力/スレーブ出力のMISO・クロックのSCLKがあります。MOSIとMISOが独立しているので送受信を同時に行う全二重通信です。マスターから選択されていないスレーブのMISOはハイインピーダンスとなるので影響を与えません。\nSPIはクロックを用いた同期通信で、比較的高速な通信が可能です。クロックには、アイドル時にHにするかLにするかを指定する極性(CPOL)と、データのサンプリングを立ち上がりにするか立ち下がりにするかを指定する位相(CPHA)の設定があり、マスターとスレーブで一致させておく必要があります。\n通信の開始・停止はCS(SS)で行うので通信するパケットに特にルールはないですが、8bitごとに通信するのが一般的です。\nSPIは比較的高速に1対多の通信が行えるので、センサーなどの周辺機器とマイコンとの通信に利用されます。また、SDカードもSPI通信で使用することができます。\n(2)マイコンのファームウェアのデバッグの方法 デバッグツールとしては、ICE、ROMエミュレータ、OCD、デバッグモニターがあります。MPUと差し替えて使用し、MPUがどう動作するかエミュレートするのがICE(In-Circuit Emulator)です。MPUごとにMPUよりも複雑なICEを開発する必要があるため非常に高価であり、今は主流ではありません。プログラムを動作させるMPUではなくプログラムを格納するROMを差し替えて動作中のROMの様子を調べるのがROMエミュレータです。マイコンにROMが内蔵されるようになったため、これも主流ではありません。現在一般的に使われているのはOCD(On-chip Debug)です。デバッグしたいマイコン自身がもつデバッグ用の機能を外部から利用するもので、JTAGやSWDといった規格が有名です。デバッグモニターはマイコンとPCなどを接続し、マイコンのソフトウェアからシリアル通信などで必要なデータを送信するものです。単純なLチカデバッグやprintfデバッグもデバッグモニターといえます。\nOCDを使うと、プログラムを一つずつ実行したり、マイコン内部の様々な状態を取得したり、高度なデバッグができる。デバッグモニタではソフトウェアで書いた少ないデータしか読み取れませんが、簡単にデバッグができます。\nこのようなデバッグツールを使った上で、バグを洗い出し、さらにバグの原因を特定して修正する必要があります。バグの洗い出しでは、細かいモジュールごとにテストを繰り返して早期にバグを発見することが重要です。テストには、機能仕様に基づいたブラックボックステストや、プログラムの内部実装に基づいたホワイトボックステストがあります。\nテストで見つけたバグの原因を特定するときは、プログラムが動作する理由をしっかり理解したうえで、その仕組みを小さな構成要素に切り分けて一つずつ調べていきます。切り分けた各部分について、デバッグツールを用いて想定通り動作しているか調べたり、条件を変えて調べたりして原因を特定し修正していきます。\n(3)感電とその対策 交流の方が危険です。同じ電圧(実効値)のときは発生するジュール熱は同じなので火傷のリスクは同じになると考えられます。しかし、人間の筋肉は電気信号に従って動いていて、直流では筋肉が硬直するのに対し、交流では筋肉が痙攣します。交流で感電した場合は心室細動がおきる可能性があり致命的です。\n感電対策として、電子機器を使うときは、漏電遮断機を使用すること、アースを接地すること、コンセントにカバーをすること、劣化した電子機器を使用しないこと、濡れた手で電子機器を触らないことに気をつけます。さらに、電子機器を作ったりメンテナンスしたりする場合には、絶縁工具を使用すること、保護具を着用すること、活線作業は原則として行わなわず、検電器で確認すること、電線は一本ずつ扱うこと、導体部を露出させないことに気をつけます。\n(4)データシートの読み取り 入力電圧 5.2.3.1. Absolute Maximum RatingsのVoltage at IOはIOVDD + 0.5 Vとなっていて、IOVDDの上限は3.63Vであるため正常に動作しません。また、tolerantという単語でデータシート内を検索するとFault Tolerant Digitalという機能が見つかりますが、これは5V tolerantではありません。\nSPI通信 4.4. SPIから分かるように、2系統のSPI通信がマスタースレーブどちらでも使用できます。\nIOVDDとDVDDの違い 1.4.2. Pin Descriptionsにあるように、IOVDDはデジタル入出力ピンの電源であり、DVDDは内部のコアの電源です。Figure 2. A system overview of the RP2040 chipにおいて、IOsのみを駆動するのがIOVDDであり、USBやADCなどの例外を除いた内部回路を駆動するのがDVDDです。\nSWDポート SWDはSerial Wire Debugの略で、マイコンのデバッグができます。2.3.4. Debugにあるように、具体的には以下のことが可能です。\n 本来主記憶装置として使われる揮発性のSRAMや、外部のフラッシュメモリへのファームウェアの格納 プロセッサの動作を手動で進めたり、動作状況を確認したりすること メモリやIOの状態の確認  出力電流 2.19.4. Padsからわかるように、1ポートからは最大12mAを出力できます。ただし、Table 621. Pin Typesからわかるようにデフォルトでは4mAで、Table 351. GPIO0,GPIO1,…,GPIO28,GPIO29 Registersのようにレジスタを書き換えることで設定を変更できます。\n5.2.3.4. IO Electrical CharacteristicsのMaximum Total IOVDD currentから、合計で50mA出力できると分かります。なお、吐き出し(sorce)電流がIOVDD currentで吸い込み(sink)電流がVSS currentで、RP2040ではどちらも50mAで同じです。\n(5)技術基準適合証明 無線通信に関係しないソフトウェアを変更することは問題ないですが、そのファームウェアが無線通信を担っている場合には違法となる可能性があります。技適のある無線ルーターのハードウェアを用いても、ソフトウェアによって無線通信の電波強度や周波数帯、送信休止時間などが変更できる場合は電波法で定められた基準に適合しなくなる可能性があるからです。この場合はハードウェアの改造と同じように扱われ、技適が無効となり違法となります。例えば、WiFiモジュールESP-WROOM-02はソフトウェアを書き換えることができますが、専用のライブラリやSDKを使っている限りでは無線通信の仕様には関係ない部分のソフトウェアを書くことになるため、認証には影響はありません。しかし、SDRに関わるソフトウェアを変更する場合には違法となる可能性があると考えられます。　(366字)\n","description":"","id":8,"section":"blog","tags":["セキュリティ・キャンプ"],"title":"セキュリティ・キャンプ2022 X3 応募課題晒し","uri":"https://771-8bit.com/blog/seccamp-assignment/"},{"content":"DashWareというソフトウェアを使い、自作ロガーで取得したデータを動画にオーバーレイ表示する方法をまとめました。\nDashWareとは DashWareは、ロガーで取得したデータを動画にオーバーレイ表示できるソフトウェアです。車・自転車・ドローンなどレースの編集によく使われているようですが、鳥人間コンテストやハイブリッドロケットの動画編集でも便利だと思います。\nネットには既製品のロガーでの使い方はありましたが、自作ロガーへの対応はほぼ手探りで調べたことをまとめたので間違いがあるかもしれません。\nDashWareの使い方 インストール 公式サイトからダウンロードできます。\nプロジェクトの作成 File -\u0026gt; New Projectより、新しいプロジェクトを作成します。Project Templateはデフォルトで表示されるゲージの設定だけなので\u0026lt;None\u0026gt;で問題ありません。\n動画の読み込み 以下のように動画を読み込みます。\nデータの読み込み 同様にデータを読み込みます。\nここからEdit ProfilesをクリックしてData Profileの設定に移ります。\nData Profileの作成 Data Profileを設定することで自作ロガーに対応させます。この記事の本題です。\nここでDashWare Loggerをクローンして自作ロガー用のプロファイルを作成します。名前はMy Loggerにしました。\nCSVのフォーマット 自作ロガーからデータをCSVで吐き出し、Separator Settingで設定した区切り文字、Decimal Formatで設定した小数点にフォーマットを合わせます。\n1行目にはHeader Lineなるものが必須のようで、\u0026ldquo;hello\u0026quot;など適当な文字列を置いておく必要があります。\nCSVファイルは以下のようになります。\n \u0026ldquo;hello\u0026rdquo;\n\u0026ldquo;Time\u0026rdquo;,\u0026ldquo;Elevation Meters\u0026rdquo;\n0,-0.3609\n0.1,-0.3809\n0.2,-0.4609\n0.3,-0.4609\n\u0026hellip;\n データ名の対応 2行目に指定するデータ名は、Column Mappingsで指定します。Column Mappingsの行をダブルクリックし、Data Column Mapping Editorを開きます。\nInput ColumnのInput Data ColumnでCSVファイルに書いたデータ名を指定します。ドロップダウンリストではなくコンボボックスなので好きな文字列を入力できます。ラジオボタンは文字列を含むか完全に一致するかどちらでデータを取り込むかの選択です。CSVファイルでデータ名はダブルクォーテーションをつけることに注意してください。\nColumn Mappingでは、取り込んだデータをDashWare内でなんという名前で扱うかを指定します。カテゴリーとその中の種類を指定するようになっていて、選択肢にないものは選べません。\n時間の設定 時間をもとに動画と同期させるので\u0026quot;Time\u0026quot;は\u0026lt;Required\u0026gt;となっていて必須です。CSVファイルの\u0026quot;Time\u0026quot;の列を時間として読み取ります。単位は秒で正の数しか受け付けません。\nカウントダウンを含む場合など、負の時間を含む場合はこれとは別にデータ列を用意します。\nゲージの設定 Guage ToolBoxから好きなゲージを動画の部分にドラッグアンドドロップして追加します。\nこれをダブルクリックすると詳細な設定が可能ですが、基本的にはColumn Mappingでカテゴリーとデータの種類を適切に設定していれば設定を変更する必要はありません。\n同期 Synchronizationを開いて動画とデータの同期を行います。この操作に関しては公式のチュートリアル動画の0:45以降が分かりやすいです。\n書き出し File -\u0026gt; Create Videoから完成した動画を書き出せます。\n作成例    ハイブリッドロケットの打ち上げの動画をDashWareを使って編集しました。この詳細は別の記事に書きました。\n","description":"","id":9,"section":"blog","tags":["ロケット","鳥人間","ドローン","電子工作"],"title":"【DashWare】自作ロガーのデータを動画にオーバーレイ","uri":"https://771-8bit.com/blog/dashware/"},{"content":"第20回伊豆大島共同打上実験に参加し、自作ロケットを打ち上げました。\n伊豆大島共同打上実験は、全国の大学生によるハイブリッドロケットの打上実験です。私はCOREのメンバーとして参加しました。COREはハイブリッドロケットの製作・打上げを行う関東圏のインカレです。打ち上げたロケットCANVASは新入生が中心となって製作を行い、私は電装部分を担当しました。\n   打ち上げの様子とロケットのノーズに搭載したカメラの映像、取得したデータをまとめました(DashWareを使用)。\nロケットの詳細は報告書として共同打上実験のHPに公開しています。以下に公開する事柄はこの報告書に全て記述されています。\nこのミッションでは新入生教育を背景として、基礎的なロケットを作ることを目標としました。電装系としては、頂点で開放機構を動作させることとセンサーとカメラのデータを回収することが目標でした。機能としてはシンプルなため一つのマイコンで制御可能ですが、確実に動作する電装を作り、その開発体制をこれから維持できる基盤を作るため、CAN通信を採用したのが今回の電装の特徴です。CAN通信の具体的なメリットは報告書にまとめました。特に、COREはインカレであるためCANでモジュールを分割することにより開発を分担しやすくなりました。CANを使用した以外にも、通信の途絶やモジュールの故障、アップリンクやプログラム書き込みでの操作ミスなど様々なリスクを考慮し、動作テストを繰り返して信頼性を高めました。\n打ち上げ当日は問題なく電装は動作し、パラシュートの開傘とデータの回収に成功しました。取得したデータの詳細は報告書にあります。\n   打ち上げ時の地上局の録画\nハイブリッドロケットの電装は機能としてはシンプルで高度な制御は行っていませんが、本番一回の打ち上げで確実に動作させるという点に難しさと楽しさがあると思っています。打ち上げと全く同じ状況を地上で再現することはできないため、様々なことを考えて設計・製作をする必要があります。打ち上げ時はとても緊張し、パラシュートが開いたときは手が震えるほど嬉しかったです。これからもこの分野でのものづくりを続けていきます。\n","description":"","id":10,"section":"blog","tags":["ロケット"],"title":"第20回伊豆大島共同打上実験","uri":"https://771-8bit.com/blog/izuoshimarocket-20/"},{"content":"pyserialとPySimpleGUIを使ってシリアルモニタを作りました。ArduinoをGUIで操作できます。\n使用したライブラリ pyserial pyserialを使うとPythonでシリアル通信を行えます。これだけでArduinoとの通信は可能ですが、今回はGUIにするためPySimpleGUIも使用しました。\nPySimpleGUI PySimpleGUIはPythonでGUIを扱うためのライブラリで、tkinter・Qt・WxPython・Remiといった既存のライブラリをまとめて簡単にコードを書けるようにしたものです。学習コストをかけずサクッとGUIアプリを作りたい場合は、簡単に書けるPythonとこのライブラリの組み合わせが最適だと思います。\nシリアルモニタ このようなシリアルモニタを自作できます。\nコード全体をのせます。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68  import PySimpleGUI as sg import serial import serial.tools.list_ports import time import threading coms = serial.tools.list_ports.comports() comlist = [] for com in coms: comlist.append(str(com.device)) sg.theme(\u0026#39;DarkBlack\u0026#39;) layout = [[sg.Text(\u0026#39;COMポート\u0026#39;),sg.Combo(comlist, size=(10, 1),key=\u0026#39;selectCOM\u0026#39;, enable_events=True),sg.Text(\u0026#39;\u0026#39;,size=(16, 1),key=\u0026#39;com_state\u0026#39;),sg.InputText(\u0026#39;\u0026#39;, size=(18, 1), key=\u0026#39;uplink\u0026#39;),sg.Button(\u0026#39;送信\u0026#39;, key=\u0026#39;send\u0026#39;)], [sg.Output(size=(97,10))] ] window = sg.Window(\u0026#39;Serial Monitor\u0026#39;, layout,enable_close_attempted_event=True) ser = serial.Serial() ser.baudrate = 115200 ser.timeout = 0.1 def GUIloop(): while True: event, values = window.read() if event == \u0026#34;-WINDOW CLOSE ATTEMPTED-\u0026#34;: if(sg.popup_ok_cancel(\u0026#34;終了しますか？\u0026#34;)==\u0026#39;OK\u0026#39;): ser.close() window.close() break if event == sg.WIN_CLOSED: #ウィンドウのXボタンを押したときの処理 break if event == \u0026#39;selectCOM\u0026#39;: if ser.is_open: ser.close() ser.port = values[\u0026#39;selectCOM\u0026#39;] ser.open() if event == \u0026#39;send\u0026#39;: try: ser.write(values[\u0026#39;uplink\u0026#39;].encode()) window[\u0026#39;uplink\u0026#39;].update(\u0026#39;\u0026#39;) except: print(\u0026#39;err\u0026#39;) def COMloop(): while True: if ser.is_open: window[\u0026#39;com_state\u0026#39;].update(\u0026#39;connected\u0026#39;) try: text=ser.readline().decode(\u0026#39;UTF-8\u0026#39;).rstrip() print(text) except: time.sleep(0.1) else: window[\u0026#39;com_state\u0026#39;].update(\u0026#39;disconnected\u0026#39;) time.sleep(0.1) thread_GUI = threading.Thread(target=GUIloop) thread_COM = threading.Thread(target=COMloop, daemon=True) thread_GUI.start() time.sleep(0.5) thread_COM.start() time.sleep(1)   PySimpleGUI PySimpleGUIについては以下の記事を参考にしました。\n Pythonでも簡単にGUIは作れる  ドロップダウンリストを利用したCOMポートの選択 pyserialの機能で使用可能なCOMポートをlistで受け取れます。この要素を文字列に変換してPySimpleGUIのコンボボックスに追加しています。valuesを通して選択された文字列が受け取れるので、これをもとにCOMポートを開くことができます。\n PySimpleGUIを使ったドロップダウンリストの作成方法について PysimpleGui コンボボックスを動的に変化させる方法  pyserialでの文字列の送受信 文字列ではなくバイナリデータとしてシリアル通信を行うので、送信時は'文字列'.encode()とする必要があります。逆に受信時はser.readline().decode('UTF-8')とします。このプログラムではさらにrstrip()を使いました。\n 【TIPS】Pythonでシリアル通信するpyserialの使い方と動作確認方法[Windows版] Pythonで文字列の前にBをつける  GUI用スレッドとCOMポート用スレッドの処理 GUI用ループとCOMポート用ループを別で走らせるためにデーモンを使用しました。\n Pythonのthreading使ったらプログラムが止まらなかったパターンがある 【Python】スレッドのデーモン化について  応用 これを応用して少し込み入ったGUIも実装できます。これはハイブリッドロケットの地上局のソフトウェアです。この詳細は別の記事に書きました。\n  ","description":"","id":11,"section":"blog","tags":["電子工作","Python"],"title":"pyserialとPySimpleGUIでシリアルモニタ","uri":"https://771-8bit.com/blog/pyserial/"},{"content":"【Lチカの先へ】データシートを読んでセンサーをArduinoで使えるようになる最短ルートとしてelchikaに投稿したものの最新版です。\nはじめに センサーの専用ライブラリに頼らず「データシートを読んでセンサーをArduinoで使える」人が、初心者を同じレベルまで電子工作ができるように教育することを想定しています。Lチカまではたくさん資料があるけど、そこから先はどうすれば…と思って自分のメモとして書きました。そのため、初心者の人がこれを読んで自力で学ぶには不親切かもしれません。目標のセンサーは秋月のセンサーモジュールぐらいのつもりです。\n質の高い書籍や資料は存在しますが、何か一つの資料だけで完璧に習得できるということはまずなく、完璧な入門書を使うとその先が分からなくなるということもあるので、様々な資料を使いながら電子工作に慣れていくというのが良いかなと思います。その主軸として、特に以下のことを考えてこのプランを作りました。\n 本やネットの内容をコピーするのではなく、自分でものを作れること 問題を解決する能力をつけること、問題を回避する能力をつけること 自分でさらに知識をつけることができる基盤を作ること  やること やることを順番にまとめて、学べることを箇条書きにしました。マイコンはSeeeduino XIAOを想定しています。\n魚ではなく魚の釣り方を教えるイメージで以下の通りにすれば、電子工作がある程度できるようになると思います。\nチカチカ チカチカ(非安定マルチバイブレータ)を回路図を読んで作ります。できればコンデンサや抵抗を変えて周期の変化を確かめたり、波形をオシロで見せつつ仕組みの解説をしたいところです。\n 回路図の読み方 ブレッドボードの使い方 電子回路  LEDと保護抵抗 コンデンサ(RC回路) トランジスタのスイッチング   はんだ付け  Lチカ まずはLチカでArduinoの基本的な使い方を学びます。プログラミングも初心者の場合はここからゆっくりプログラミングについて教えます。\n Arduino IDEの使い方 デジタル出力  スイッチでLEDのON/OFF スイッチを押したらLEDが光るようにします。\n デジタル入力 プルアップ・プルダウン  PCとシリアル通信 スイッチが押されたらPCにシリアル通信をするプログラムを書きます。printデバッグ用に早めにこれをやると良いかなと思います。押されている間ずっと通信するのではなく押された瞬間に通信するプログラムにします。\n PCとのシリアル通信 スイッチのチャタリング  可変抵抗でLEDの明るさ調整 可変抵抗で分圧回路を作り、それをADCで読み取ってLEDの明るさを調整します。LEDの降下電圧を確認するため、DAC→PWMの順で実践します。PWMの出力波形をオシロで見せられると良いです。\n 分圧 ADC DAC PWM (analogWrite)  Seeeduino XIAOのADC(analogRead)はすべてのピンで10bit、analogWriteは0番ピンのみDACでデフォルトは10bit、それ以外のピンはPWMでデューティー比は8bitで設定できます。詳細はこちらの記事を参照してください。\n圧電ブザー LEDだけだとつまらないので音を出してみます。まずは単純にONOFFを繰り返すプログラムを書いてPWMについて理解したあと、tone関数を使ってみると良いと思います。圧電ブザーはミニゲームでも活用できます。\n PWM  サーボモータ PWMを素直に書いたあと、Servoライブラリを導入すればライブラリについても学べます。\n PWM ライブラリ  スイッチでLEDの点灯/点滅 複数のセンサーや周辺機器を制御することを想定して、あるLEDを一定周期で点滅させつつ、別のLEDのON/OFFをスイッチで切り替えられるようにします。まずはタイマや割り込みを使わないでプログラムを組んで、delay中はスイッチの判定ができないことを確認します。タイマと割り込みについて解説した後、以下のような方法で実装します。\n delayで点滅し、割り込みでスイッチを監視する方法 delayで点滅し、ピン変化割込みでスイッチを監視する方法 タイマ割り込みで点滅し、loopでスイッチを監視する方法 時間関数を使って点滅し、loopでスイッチを監視する方法  Seeeduino XIAOのタイマ割り込みは、Arduino IDEのスケッチ例を参考にしてください。ピン変化割り込みでは、ピンの番号に注意してください。\nこのように割り込みには様々な使い方がありますが、以下の方針で使う方法を選ぶと良いと思います。\n 優先度の高いタスクを割り込みで実行する 割り込みルーチンの実行時間を短くする プログラム全体でdelay関数を使わないでいいようにする  学ぶのは以下の内容です。\n タイマ 割り込み  LEDとスイッチでミニゲーム 数個のLEDとスイッチのセットで作れるミニゲームを実装します。光ったLEDに当たるスイッチを制限時間内に押すモグラ叩きゲームがちょうど良いと思います。これに圧電ブザーを加えてみても良いです。ここでじっくり自力で仕様を考えてプログラムを組んでデバッグすることが重要です。\n 変数や制御文などの\u0026quot;プログラム\u0026quot; デバッグ  部品を壊す 予期しないタイミングで部品を壊してしまうよりは、一度簡単な部品を壊す経験をしてしまう方が安全だと思います。その経験としてLEDを保護抵抗無しで電源(保護回路あり)に直接つなげます。電解コンデンサの逆接は危険ですが、LEDの破壊程度であれば何かカバーを被せれば十分安全に試せると思います。\n 絶対最大定格 故障モード\nLEDの破壊の様子はYouTube等で見ることができます。実験の前に動画を見て危険だと思われる場合は、LEDの破壊の代わりに適切な抵抗を挟んだうえでヒューズを溶断してみるのをおすすめします。   センサ(ADC) いきなりシリアル通信は難しいので、ADCで読めるセンサを使います。\n データシートの読み方  センサ(シリアル通信) シリアル通信(ArduinoのSerial(UART)に限らず)で読めるセンサを使います。Arduinoのコードをなんとなく追うのではなく、まずシリアル通信のプロトコルについてしっかり理解して、どんな信号がやりとりされているのかを把握するべきです。その後Arduinoの関数の役割を理解すれば詰まることなく進められるはずです。\n シリアル通信  使う部品・サンプルコード  サンプルコードはGitHubで公開しています。Seeeduino XIAOを使うことを想定しています。\n必要な知識・スキル 知識そのものを自分で書くと時間が足りないので、いい感じの資料をまとめました。もちろん全部覚えてもらうことはないです。\nほぼ全ての基礎\n電子工作のための電子回路基礎\nArduinoをはじめよう 第3版\n組込みエンジニアの教科書\n実際の製作  はんだ付け\nまずはこれ(村田製作所)\n細かいこと1(HAKKO)\n細かいこと2(GodHanda) ブレッドボードの使い方  プログラミング  C++入門 AtCoder Programming Guide for beginners 苦しんで覚えるC言語  Arduino・マイコン 公式Arduinoリファレンス\ngarretlab\nNOBのArduino日記！\nspiceman\n そもそもコンピュータ・マイコンとは\nDigikey(動画)\nそもそも「マイコン」って何？ マイコンやセンサーを動かすための外部の回路  電源(レギュレータ・コンデンサなど) プルアップ・プルダウン   マイコンの機能  入出力 ADC DAC タイマ PWM 割り込み シリアル通信  UART SPI I2C仕様書  I2C概要 ArduinoでI2C        一般の回路・部品  Electrical Information\nマイコン以外の電子部品、電気・電子回路 秋月のカタログ\n使える武器が増えるのでどんなカテゴリがあるか知っておいた方が良いです。 リチウム二次電池の扱い  Lipoの基礎 電池回収@ビックカメラ：塩水にはつけずに回収BOXへ LiPoバッグ    単純な技術以外のスキル 問題解決・問題回避 もの作りで一番必要なのは失敗が許容される状況だと思います。無計画でいいというわけではなく、大きな失敗を避けること、失敗してもそれを解決できることが重要です。(チームの場合は人間関係がゴタゴタしないことも重要)\n 問題回避\n最初から完璧を目指して全部作って最後に動作確認をすると、問題の原因特定が困難です。ある程度の機能を作ったら動作テストを心がけ、細かい失敗を前提とした製作をします。Done is better than perfect. 問題解決\n経験があれば問題から直接原因を推測したり、よく観察してすぐに原因を特定できたりしますが、慣れないうちは以下の手順を丁寧に行うことをおすすめします。  分割する\n動かない理由を特定するには、当然ですが動く理由をしっかり理解していることが必要です。そのうえで、仕組みを小さな構成要素に切り分けて一つずつ調べていきます。仕組みの最初から最後まで順番に調べていくのは手間が手間がかかり、どの程度細かく分割すればいいか分からなくなるので、二分探索の要領で進めていくと良いです。 チェックする\n切り分けた各部分について、以下の方法で問題ないか調べていきます。\nA 想定通り動作しているか調べる\nB 条件を変えて調べてみる(対照実験) 分からないことはググる/人に聞く\n質問の仕方     LEDが光らないなら、まずマイコン側と回路側で分割します。テスターを使ってマイコンから正しい電圧が出ていることが分かれば(A)、問題は回路側にあることになります。LEDが故障しているなら、LEDを交換する(B)ことで原因にたどり着くはずです。これは単純な例ですが、複雑な問題も同じように解決できます。\n データシートの読み方 読んで慣れるしかない？\nなにかアドバイスあればコメントください。\n公式ドキュメントの扱い方 公式サイトと他のサイトはそれぞれどちらも長所短所があるので、使い分けを意識します。\n 他のサイトを見て全体像を把握する 公式サイトにたどり着く まずサイトの構成を知る 必要な所を読む   公式ドキュメント(公式リファレンスとも)\nその技術や製品そのものについて書いてある\nそれの仕様,使い方をちゃんと学べる 信頼性が最も高い(外部サイトは情報が古いかも) 他のサイト  それを外部の視点から書いたもの\n他の技術や製品と比べて書いてある 外から見るので全体像が掴める 公式に書いてないことを書いたもの\nバグは外部サイトに書いてある事が多い 公式の記述を要約しているもの\n分かりやすいけど結局公式のトップページが神    おすすめの工具・測定器 おすすめの工具・測定器を布教して終わりにします。\n はんだごて FX600 こて台 633-01 こて先 2.4D型 T18-D24 ハンダ吸取器 SS-02   はんだ吸煙器 オシロスコープ HDS2102S ","description":"","id":12,"section":"blog","tags":["電子工作","Arduino"],"title":"電子工作入門","uri":"https://771-8bit.com/blog/for-beginners/"},{"content":"「CPUの創りかた」のTD4を製作しました。製作時点で購入できた部品についてまとめてあります。\n作ったもの ロジックICで自作する4bit CPUを「CPUの創りかた」をもとに作りました。集積度が高いのが好きなので、秋月電子のユニバーサル基板のBタイプに収めてあります。実際に作ってデバッグしていくとCPU内のデータの流れがよく理解できました\nデバッグしやすいように動作確認がとれる部分ごとに製作していきました。\n ROMを作って単体で動作確認 クロック回路を作って単体で動作確認 命令デコーダを作ってROMとクロック回路をつなげて動作確認 残りをすべて実装して完成  ROM TD4のオリジナルの回路に加えて、実行中の命令を示すLEDをつけました。ダイオードはカソードコモンのダイオードアレイを使っています。使用したDIPスイッチは幅が狭く実装密度を上げたい場合はおすすめです。\nTD4のROM\n(74HC540買い忘れ) pic.twitter.com/1vrP5s8ATu\n\u0026mdash; 8bitマイコン (@771_8bit) September 19, 2021 普通のDIPパッケージの部品を使うときもハーフピッチ基板を使うとピンの隙間に配線を通せて便利です。\nクロック回路 ICの電源ピンからクリップで電源を供給して動作確認しました。\nTD4のクロック回路(と自作オシロ) pic.twitter.com/CvYocwevLy\n\u0026mdash; 8bitマイコン (@771_8bit) September 20, 2021 命令デコーダ 同じ種類のゲートを入れ替えて配線が簡単になっています。\n動作テスト pic.twitter.com/JgnaEWmPwb\n\u0026mdash; 8bitマイコン (@771_8bit) September 20, 2021 CPU中心部 74HC161はSOPパッケージのものしか入手できなかったのですが、ICの裏に配線を通したかったので変換基板を使って表側に実装しました。レジスタAとレジスタBの値を青色LEDで示せるようになっています。出力レジスタは出力のLEDで、プログラムカウンタはROMの緑色LEDで確認できます。\nTD4完成！ pic.twitter.com/Sthn8hqvNx\n\u0026mdash; 8bitマイコン (@771_8bit) September 23, 2021  主要部品購入先 74HC154は入手できなかったため、こちらの記事を参考に74HC138で置き換えました。3-to-8デコーダを2つ使って4-to-16デコーダを作ります。\n   オリジナル  用途 型番 購入先     74HC74 キャリーフラグ TC74HC74AP (フリッププロップ) 秋月   74HC161 レジスタ・プログラムカウンタ TC74HC161AF (4ビットカウンタ) 秋月   74HC153 データセレクタ TC74HC153AP (4chマルチプレクサ) 秋月 マルツ   74HC32 命令デコーダ TC74HC32AP (OR) 秋月   74HC283 ALU CD74HC283E (加算器) 千石   74HC10 命令デコーダ TC74HC10AP (NAND) 千石   74HC154 アドレスセレクタ TC74HC138AP (3-to-8ラインデコーダ) 秋月   74HC540 アドレス出力 TC74HC540AP (インバータ) 千石   74HC14 クロック回路 TC74HC14AP (シュミットトリガ) 秋月   DIPスイッチ ROM KSD82 (DIPスイッチ 8P) 秋月   ダイオード ROM CE880 (ダイオードアレイ) 秋月    詰まったところ カウンタICの使い方 TD4ではカウンタICのカウントアップ機能を殺してレジスタを作ります。最初はこのあたりをよく理解せずに配線を始めていて、74HC161のENTピンとENPピンをLに落としていませんでした。このため電源を入れるとレジスタAとBが勝手にカウントアップしました。加算回路を調べても正常だったので本を読み直すとICのカウントアップ機能が原因だったことが分かりました。\nプルアップ配線ミス スイッチのプルアップ抵抗を電源側ではなくスイッチ側につけてしまいました。これは実装した翌日に基板を見て気づきました。製作物も製作者も一晩寝かすとデバッグが進みますよね。\nはんだ付け接触不良 レジスタAが常にロードされるような挙動から、レジスタAの74HC161の接触不良に気づきました。\nセキュキャンのLT会資料 セキュリティ・キャンプ全国大会2022のLT会でTD4について発表しました。\nロジックICから4bit CPUを作る by @771_8bit","description":"","id":13,"section":"blog","tags":["電子工作"],"title":"TD4作ってみた","uri":"https://771-8bit.com/blog/td4/"},{"content":"秋月電子で取り扱いの始まったCO2センサーMH-Z19CをArduino Nano Everyで使ってみました。\nこの記事はQiitaに投稿した記事を再掲したものです。\nMH-Z19Cについて MH-Z19CはNDIR方式のCO2センサで、電源電圧は5.0±0.1V、データの出力はPWMかUART(3.3Vで5.0Vにも対応)です。測定できる範囲はPWMを使うと公称値は400~2000ppm(実測では400~5000ppm)、UARTでは400~5000ppmです(CO2濃度は大気中で約400ppm、室内で約1000ppm、呼気で約30000ppmが目安)。ピンヘッダは2.54mmピッチですが、ピンヘッダとピンヘッダとの間隔が合わずユニバーサル基板に挿すのは難しいので注意してください。\nここでは5V駆動のArduino Nano Everyを使い、PWMとUART両方のデータを読んでみます。\nハードウェア 使ったもの  MH-Z19C Arduino Nano Every 5Ｖ出力昇圧DCDCコンバーターとコンデンサー  Arduinoの5V OUTピンの電圧を測ると4.72-4.78Vでセンサーの電圧の範囲から外れていたので、一応4.9~5.1V出力(実測4.98V)のDCDCコンバーターと100μFのコンデンサーをつけました。\n接続    MH-Z19C      Vin DCDCコンバーター ← Arduino 3.3V   GND Arduino GND   PWM Arduino A7   Hd Arduino A6   Rx Arduino TX1   Tx Arduino RX1    ソフトウェア MH-Z19Cの仕様 データシートはここで読めます。以下の画像はデータシートのものです。\nUART UARTでCO2濃度の読み取りと自動キャリブレーションの設定ができます。\nPWM データシートでは上のようになっていますが、Cppm=5*(パルス幅[ms]-1.2)とするとUARTと同じデータが読み込めました。Arduino Nano EveryのpulseInかセンサーのPWM出力のどちらかが原因だと思います。\n手動キャリブレーションはHdピンを使うのでPWMでもできますが、自動キャリブレーションの設定はPWMだけではできません。デフォルトでは24時間ごとに自動キャリブレーションが行われます。(キャリブレーション時にどんな濃度でもそれを400ppmと認識するのではなく、24時間経ったあたりで400ppmに近い状態と判断するとキャリブレーションを行うようです)\nプログラム 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50  uint16_t uartco2; unsigned long pwmco2; bool reset = false; byte ReadCO2[9] = {0xFF, 0x01, 0x86, 0x00, 0x00, 0x00, 0x00, 0x00, 0x79}; byte SelfCalOn[9] = {0xFF, 0x01, 0x79, 0xA0, 0x00, 0x00, 0x00, 0x00, 0xE6}; byte SelfCalOff[9] = {0xFF, 0x01, 0x79, 0x00, 0x00, 0x00, 0x00, 0x00, 0x86}; byte retval[9]; void setup() { pinMode(A7, INPUT); pinMode(A6, OUTPUT); Serial.begin(9600); Serial.print(\u0026#34;400ppm\u0026#34;); Serial.print(\u0026#34;,\u0026#34;); Serial.print(\u0026#34;UART\u0026#34;); Serial.print(\u0026#34;,\u0026#34;); Serial.println(\u0026#34;PWM\u0026#34;); delay(2000); Serial1.begin(9600); Serial1.write(SelfCalOn,sizeof SelfCalOn); } void loop() { //PWMでデータ取得  pwmco2=pulseIn(A7,HIGH,2000000); //UARTでデータ取得  Serial1.write(ReadCO2,sizeof ReadCO2); Serial1.readBytes((char *)retval, sizeof retval); uartco2 = retval[2]*256 + retval[3]; //PCに送信  Serial.print(2*(202000-2000)/1000); Serial.print(\u0026#34;,\u0026#34;); Serial.print(uartco2); Serial.print(\u0026#34;,\u0026#34;); Serial.println(5*(pwmco2-1200)/1000); delay(100); //起動20分後手動キャリブレーション  if(millis()\u0026gt;1200000 \u0026amp;\u0026amp; !reset){ digitalWrite(A6,LOW); delay(8000); digitalWrite(A6,HIGH); reset=true; } }   測定結果 Arduino IDEのシリアルプロッタを使って可視化しました。縦軸がCO2濃度[ppm],横軸が起動からの時間(1が100ms)です。\n  換気したとき\n  人が部屋に入ってきたとき\n横軸1600ぐらいで部屋に入っています。\n  直接息をふきかけたとき\n息をふきかけた直後に値が上昇しました。\n ","description":"","id":14,"section":"blog","tags":["電子工作","Arduino"],"title":"秋月で買えるCO2センサーを使う(MH-Z19C)","uri":"https://771-8bit.com/blog/mh-z19c/"},{"content":"第15回全日本学生室内飛行ロボットコンテストのマルチコプター部門に出場しました。\n飛行ロボコンのマルチコプター部門では、自作したマルチコプターを飛行させ各ミッションを行います。私は高校の航空宇宙同好会として参加し、機体製作を担当しました。このチームでは、カメラで正しい箱を探して物資を投下する「高所物資運搬」、機体重量350gに対し100g程度の物資を運ぶ「大型物資運搬」、決められたコースを飛行する「8の字飛行」の3つのミッションを行いました。\n 機体 予選 決勝  マルチコプター部門には11チームが出場し、予選は3位タイで通過、決勝は4位となりました。大学・高専が中心の大会で普通科高校としては初出場ということもありましたが、あまり良い結果を残せませんでした。会場の通信環境やパイロットからの視点が想定より厳しかったこと、十分な操縦練習時間がとれなかったこと、飛行時間を優先した部品構成にしたため衝突に弱い構造になってしまったことなどが主な原因です。このため予選では8の字飛行に時間がかかり途中でミッションを諦めて帰還し、決勝では大型物資を正しい場所に投下できず、8の字飛行の途中でポールに衝突し棄権という結果になりました。\nそれでも予選ではマニュアル通りの正しい判断で時間内の帰還には成功して決勝に進め、決勝でもメインミッションである高所物資運搬は達成できました。様々反省点はありますが、ロボコンの本番の空気を味わうことができたり、ただものを作るだけではなく本番で運用する難しさが分かったり、良い経験になりました。\n","description":"","id":15,"section":"blog","tags":["ドローン"],"title":"第15回全日本学生室内飛行ロボットコンテスト","uri":"https://771-8bit.com/blog/indoor-flight-15/"}]